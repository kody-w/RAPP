<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D&D Campaign Manager - Multiplayer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e4e4e4;
            min-height: 100vh;
        }

        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            padding: 30px 0;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 15px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header h1 {
            font-size: 3em;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            color: #a0a0a0;
            font-size: 1.1em;
        }

        .connection-panel {
            background: rgba(30, 30, 60, 0.8);
            padding: 25px;
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .connection-panel h2 {
            color: #4ecdc4;
            margin-bottom: 15px;
        }

        .connection-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .input-group {
            flex: 1;
            min-width: 200px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #a0a0a0;
            font-size: 0.9em;
        }

        .input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #4a4a6a;
            border-radius: 6px;
            background: rgba(20, 20, 40, 0.9);
            color: #e4e4e4;
            font-size: 1em;
        }

        .input-group input:focus {
            outline: none;
            border-color: #4ecdc4;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
            color: white;
        }

        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .connection-status {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .status-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            margin-right: 10px;
        }

        .status-connected {
            background: #44a08d;
            color: white;
        }

        .status-disconnected {
            background: #666;
            color: white;
        }

        .game-container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            gap: 20px;
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .game-container {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: rgba(30, 30, 60, 0.8);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }

        .panel h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .character-sheet {
            background: rgba(20, 20, 40, 0.6);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }

        .stat-label {
            font-size: 0.8em;
            color: #a0a0a0;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4ecdc4;
        }

        .health-bar {
            background: rgba(0, 0, 0, 0.4);
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            position: relative;
            margin: 15px 0;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b 0%, #ee5a6f 100%);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .inventory-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .campaign-log {
            max-height: 400px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .log-entry {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.05);
        }

        .log-entry.combat {
            border-left: 4px solid #ff6b6b;
        }

        .log-entry.story {
            border-left: 4px solid #4ecdc4;
        }

        .log-entry.system {
            border-left: 4px solid #a0a0a0;
        }

        .combat-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .enemy-list {
            margin-top: 15px;
        }

        .enemy-card {
            background: rgba(255, 107, 107, 0.2);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 2px solid #ff6b6b;
        }

        .enemy-name {
            font-weight: bold;
            color: #ff6b6b;
            margin-bottom: 5px;
        }

        .player-list {
            margin-top: 15px;
        }

        .player-card {
            background: rgba(78, 205, 196, 0.2);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 10px;
            border: 2px solid #4ecdc4;
        }

        .player-card.active {
            border-color: #ffd93d;
            box-shadow: 0 0 20px rgba(255, 217, 61, 0.3);
        }

        .dice-roller {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
        }

        .dice-result {
            font-size: 2em;
            text-align: center;
            color: #ffd93d;
            font-weight: bold;
            margin: 15px 0;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .scroll-container {
            max-height: 500px;
            overflow-y: auto;
            padding-right: 10px;
        }

        .scroll-container::-webkit-scrollbar {
            width: 8px;
        }

        .scroll-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .scroll-container::-webkit-scrollbar-thumb {
            background: #4ecdc4;
            border-radius: 4px;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-content {
            background: #1e1e3c;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .modal-content h2 {
            color: #4ecdc4;
            margin-bottom: 20px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #a0a0a0;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #4a4a6a;
            border-radius: 6px;
            background: rgba(20, 20, 40, 0.9);
            color: #e4e4e4;
            font-size: 1em;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .quest-card {
            background: rgba(255, 217, 61, 0.1);
            border: 2px solid #ffd93d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .quest-title {
            color: #ffd93d;
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 8px;
        }

        .quest-description {
            color: #a0a0a0;
            font-size: 0.95em;
            margin-bottom: 10px;
        }

        .quest-reward {
            color: #4ecdc4;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Game Constants
        const CLASSES = ['Warrior', 'Mage', 'Rogue', 'Cleric', 'Ranger'];
        const RACES = ['Human', 'Elf', 'Dwarf', 'Halfling', 'Dragonborn'];

        const CAMPAIGN_SCENARIOS = [
            {
                id: 1,
                name: "The Goblin Cave",
                description: "A band of goblins has been raiding nearby villages. Track them to their cave and end their threat.",
                enemies: [
                    { name: "Goblin Scout", hp: 15, maxHp: 15, ac: 13, attack: 5 },
                    { name: "Goblin Warrior", hp: 20, maxHp: 20, ac: 14, attack: 6 },
                    { name: "Goblin Chief", hp: 35, maxHp: 35, ac: 16, attack: 8 }
                ],
                xpReward: 100,
                goldReward: 50
            },
            {
                id: 2,
                name: "Ancient Ruins",
                description: "Mysterious ruins have been discovered. Explore them to uncover ancient secrets and treasures.",
                enemies: [
                    { name: "Skeleton", hp: 18, maxHp: 18, ac: 13, attack: 5 },
                    { name: "Zombie", hp: 25, maxHp: 25, ac: 12, attack: 6 },
                    { name: "Wraith", hp: 30, maxHp: 30, ac: 15, attack: 7 }
                ],
                xpReward: 150,
                goldReward: 75
            },
            {
                id: 3,
                name: "Dragon's Lair",
                description: "A young dragon has taken residence in the mountains. Defeat it before it becomes a true menace.",
                enemies: [
                    { name: "Kobold Minion", hp: 12, maxHp: 12, ac: 12, attack: 4 },
                    { name: "Kobold Shaman", hp: 20, maxHp: 20, ac: 13, attack: 6 },
                    { name: "Young Dragon", hp: 80, maxHp: 80, ac: 18, attack: 12 }
                ],
                xpReward: 300,
                goldReward: 200
            }
        ];

        // AI Bot Logic
        class AIBot {
            constructor(character) {
                this.character = character;
            }

            decideCombatAction(enemies, allies) {
                const aliveEnemies = enemies.filter(e => e.hp > 0);
                if (aliveEnemies.length === 0) return null;

                // Simple AI: 70% attack, 20% special, 10% heal if needed
                const roll = Math.random();
                const needsHealing = this.character.hp < this.character.maxHp * 0.3;

                if (needsHealing && roll < 0.3 && this.character.class === 'Cleric') {
                    return { type: 'special', target: this.character };
                }

                if (roll < 0.8) {
                    // Attack weakest enemy
                    const target = aliveEnemies.reduce((weakest, current) =>
                        current.hp < weakest.hp ? current : weakest
                    );
                    return { type: 'attack', target };
                } else {
                    // Use special ability on random enemy
                    const target = aliveEnemies[Math.floor(Math.random() * aliveEnemies.length)];
                    return { type: 'special', target };
                }
            }
        }

        // Character Creation Component
        function CharacterCreationModal({ onCreateCharacter, onCancel }) {
            const [name, setName] = useState('');
            const [race, setRace] = useState(RACES[0]);
            const [charClass, setCharClass] = useState(CLASSES[0]);

            return (
                <div className="modal">
                    <div className="modal-content">
                        <h2>Create Your Character</h2>

                        <div className="form-group">
                            <label>Character Name:</label>
                            <input
                                type="text"
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                placeholder="Enter name"
                            />
                        </div>

                        <div className="form-group">
                            <label>Race:</label>
                            <select value={race} onChange={(e) => setRace(e.target.value)}>
                                {RACES.map(r => <option key={r} value={r}>{r}</option>)}
                            </select>
                        </div>

                        <div className="form-group">
                            <label>Class:</label>
                            <select value={charClass} onChange={(e) => setCharClass(e.target.value)}>
                                {CLASSES.map(c => <option key={c} value={c}>{c}</option>)}
                            </select>
                        </div>

                        <div className="modal-buttons">
                            <button className="btn btn-danger" onClick={onCancel}>
                                Cancel
                            </button>
                            <button
                                className="btn btn-success"
                                onClick={() => onCreateCharacter({name, race, class: charClass})}
                                disabled={!name}
                            >
                                Create
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // Main App Component
        function App() {
            const [gameMode, setGameMode] = useState('menu'); // menu, singleplayer, multiplayer
            const [myPeerId, setMyPeerId] = useState('');
            const [remotePeerId, setRemotePeerId] = useState('');
            const [isHost, setIsHost] = useState(false);
            const [peer, setPeer] = useState(null);
            const [connection, setConnection] = useState(null);
            const [connectedPlayers, setConnectedPlayers] = useState([]);

            const [showCharacterCreation, setShowCharacterCreation] = useState(false);
            const [characters, setCharacters] = useState([]);
            const [currentScenario, setCurrentScenario] = useState(null);
            const [enemies, setEnemies] = useState([]);
            const [combatLog, setCombatLog] = useState([]);
            const [currentTurn, setCurrentTurn] = useState(0);
            const [inCombat, setInCombat] = useState(false);
            const [diceResult, setDiceResult] = useState(null);

            const peerRef = useRef(null);
            const connectionRef = useRef(null);

            // Initialize PeerJS
            useEffect(() => {
                if (gameMode === 'multiplayer' && !peer) {
                    const newPeer = new Peer();

                    newPeer.on('open', (id) => {
                        setMyPeerId(id);
                        console.log('My peer ID:', id);
                    });

                    newPeer.on('connection', (conn) => {
                        setupConnection(conn);
                        setConnectedPlayers(prev => [...prev, { id: conn.peer, name: 'Player' }]);
                    });

                    newPeer.on('error', (err) => {
                        console.error('Peer error:', err);
                        addLog('Connection error occurred', 'system');
                    });

                    setPeer(newPeer);
                    peerRef.current = newPeer;
                }

                return () => {
                    if (peerRef.current) {
                        peerRef.current.destroy();
                    }
                };
            }, [gameMode]);

            const setupConnection = (conn) => {
                conn.on('open', () => {
                    setConnection(conn);
                    connectionRef.current = conn;
                    addLog(`Connected to ${conn.peer}`, 'system');
                });

                conn.on('data', (data) => {
                    handleRemoteData(data);
                });

                conn.on('close', () => {
                    addLog('Player disconnected', 'system');
                    setConnection(null);
                });
            };

            const connectToPeer = () => {
                if (!peer || !remotePeerId) return;

                const conn = peer.connect(remotePeerId);
                setupConnection(conn);
            };

            const handleRemoteData = (data) => {
                console.log('Received data:', data);

                switch(data.type) {
                    case 'character_created':
                        setCharacters(prev => [...prev, data.character]);
                        addLog(`${data.character.name} joined the party!`, 'system');
                        break;
                    case 'combat_action':
                        // Handle remote player's combat action
                        addLog(data.message, 'combat');
                        break;
                    case 'scenario_start':
                        startScenario(data.scenario);
                        break;
                }
            };

            const sendData = (data) => {
                if (connectionRef.current && connectionRef.current.open) {
                    connectionRef.current.send(data);
                }
            };

            const addLog = (message, type = 'story') => {
                setCombatLog(prev => [...prev, { message, type, timestamp: Date.now() }]);
            };

            const rollDice = (sides) => {
                const result = Math.floor(Math.random() * sides) + 1;
                setDiceResult(result);
                setTimeout(() => setDiceResult(null), 2000);
                return result;
            };

            const createCharacter = (charData) => {
                const newChar = {
                    id: Date.now(),
                    ...charData,
                    hp: 100,
                    maxHp: 100,
                    level: 1,
                    xp: 0,
                    gold: 0,
                    inventory: ['Sword', 'Health Potion x3', 'Rope'],
                    isBot: gameMode === 'singleplayer' && characters.length > 0
                };

                // Roll stats
                newChar.stats = {
                    strength: rollDice(20),
                    dexterity: rollDice(20),
                    constitution: rollDice(20),
                    intelligence: rollDice(20),
                    wisdom: rollDice(20),
                    charisma: rollDice(20)
                };

                setCharacters(prev => [...prev, newChar]);
                setShowCharacterCreation(false);
                addLog(`${newChar.name} the ${newChar.race} ${newChar.class} has joined the adventure!`, 'system');

                if (gameMode === 'multiplayer' && connectionRef.current) {
                    sendData({ type: 'character_created', character: newChar });
                }

                // In singleplayer, create AI bots
                if (gameMode === 'singleplayer' && characters.length === 0) {
                    setTimeout(() => createAIPartyMembers(), 500);
                }
            };

            const createAIPartyMembers = () => {
                const botNames = ['Thorin', 'Elara', 'Grimm'];
                const botClasses = ['Warrior', 'Mage', 'Cleric'];

                botNames.forEach((name, index) => {
                    const botChar = {
                        id: Date.now() + index,
                        name: name,
                        race: RACES[Math.floor(Math.random() * RACES.length)],
                        class: botClasses[index],
                        hp: 100,
                        maxHp: 100,
                        level: 1,
                        xp: 0,
                        gold: 0,
                        inventory: ['Sword', 'Health Potion x3'],
                        isBot: true,
                        stats: {
                            strength: rollDice(20),
                            dexterity: rollDice(20),
                            constitution: rollDice(20),
                            intelligence: rollDice(20),
                            wisdom: rollDice(20),
                            charisma: rollDice(20)
                        }
                    };

                    setCharacters(prev => [...prev, botChar]);
                    addLog(`${botChar.name} the ${botChar.race} ${botChar.class} has joined the party!`, 'system');
                });
            };

            const startScenario = (scenario) => {
                setCurrentScenario(scenario);
                setEnemies(scenario.enemies.map(e => ({...e, id: Math.random()})));
                setInCombat(true);
                setCurrentTurn(0);
                addLog(`üó°Ô∏è ${scenario.name}: ${scenario.description}`, 'story');
                addLog('Combat begins!', 'combat');

                if (gameMode === 'multiplayer' && isHost && connectionRef.current) {
                    sendData({ type: 'scenario_start', scenario });
                }
            };

            const performAttack = (attacker, target) => {
                const attackRoll = rollDice(20);
                const damage = rollDice(8) + Math.floor(attacker.stats?.strength / 2 || 5);

                addLog(`${attacker.name} attacks ${target.name}!`, 'combat');
                addLog(`Roll: ${attackRoll} + ${Math.floor(attacker.stats?.strength / 2 || 5)}`, 'combat');

                if (attackRoll + Math.floor(attacker.stats?.strength / 2 || 5) >= (target.ac || 10)) {
                    target.hp -= damage;
                    addLog(`üí• Hit! ${damage} damage dealt to ${target.name}!`, 'combat');

                    if (target.hp <= 0) {
                        target.hp = 0;
                        addLog(`‚ò†Ô∏è ${target.name} has been defeated!`, 'combat');
                    }
                } else {
                    addLog(`Miss! ${target.name} dodged the attack!`, 'combat');
                }

                updateCombatEntities(attacker, target);
            };

            const performSpecialAbility = (character, target) => {
                const abilityRoll = rollDice(20);
                let damage = rollDice(12) + Math.floor(character.stats?.intelligence / 2 || 6);

                if (character.class === 'Mage') {
                    addLog(`${character.name} casts Fireball!`, 'combat');
                    damage *= 1.5;
                } else if (character.class === 'Cleric') {
                    addLog(`${character.name} channels divine energy!`, 'combat');
                    character.hp = Math.min(character.hp + damage, character.maxHp);
                    addLog(`üíö ${character.name} heals for ${damage} HP!`, 'combat');
                    updateCombatEntities(character, null);
                    return;
                } else if (character.class === 'Rogue') {
                    addLog(`${character.name} performs a sneak attack!`, 'combat');
                    damage *= 2;
                }

                if (abilityRoll >= (target.ac || 10)) {
                    target.hp -= Math.floor(damage);
                    addLog(`‚ú® Critical hit! ${Math.floor(damage)} damage dealt!`, 'combat');

                    if (target.hp <= 0) {
                        target.hp = 0;
                        addLog(`‚ò†Ô∏è ${target.name} has been defeated!`, 'combat');
                    }
                } else {
                    addLog(`The ability missed!`, 'combat');
                }

                updateCombatEntities(character, target);
            };

            const updateCombatEntities = (attacker, target) => {
                setCharacters(prev => prev.map(c =>
                    c.id === attacker.id ? {...attacker} : c
                ));

                if (target && target.id) {
                    setEnemies(prev => prev.map(e =>
                        e.id === target.id ? {...target} : e
                    ));
                }
            };

            const nextTurn = () => {
                const allCombatants = [...characters, ...enemies].filter(c => c.hp > 0);

                if (enemies.every(e => e.hp <= 0)) {
                    endCombat(true);
                    return;
                }

                if (characters.every(c => c.hp <= 0)) {
                    endCombat(false);
                    return;
                }

                const nextTurnIndex = (currentTurn + 1) % allCombatants.length;
                setCurrentTurn(nextTurnIndex);

                const currentCombatant = allCombatants[nextTurnIndex];
                addLog(`${currentCombatant.name}'s turn!`, 'system');

                // AI bot turn
                if (currentCombatant.isBot) {
                    setTimeout(() => {
                        const bot = new AIBot(currentCombatant);
                        const action = bot.decideCombatAction(enemies, characters);

                        if (action) {
                            if (action.type === 'attack') {
                                performAttack(currentCombatant, action.target);
                            } else {
                                performSpecialAbility(currentCombatant, action.target);
                            }
                            setTimeout(nextTurn, 1500);
                        }
                    }, 1000);
                }
            };

            const endCombat = (victory) => {
                setInCombat(false);

                if (victory) {
                    addLog(`üéâ Victory! The party has defeated all enemies!`, 'story');
                    const xp = currentScenario.xpReward;
                    const gold = currentScenario.goldReward;

                    setCharacters(prev => prev.map(c => ({
                        ...c,
                        xp: c.xp + xp,
                        gold: c.gold + gold,
                        hp: c.maxHp
                    })));

                    addLog(`Gained ${xp} XP and ${gold} gold!`, 'system');
                } else {
                    addLog(`üíÄ Defeat... The party has fallen.`, 'story');
                }

                setCurrentScenario(null);
                setEnemies([]);
            };

            // Render Functions
            const renderMenu = () => (
                <div className="connection-panel">
                    <h2>Welcome to D&D Campaign Manager</h2>
                    <div style={{marginTop: '20px'}}>
                        <button
                            className="btn btn-primary"
                            onClick={() => {
                                setGameMode('singleplayer');
                                setShowCharacterCreation(true);
                            }}
                            style={{marginRight: '10px'}}
                        >
                            Play Solo (with AI Bots)
                        </button>
                        <button
                            className="btn btn-success"
                            onClick={() => setGameMode('multiplayer')}
                        >
                            Multiplayer Mode
                        </button>
                    </div>
                </div>
            );

            const renderMultiplayerSetup = () => (
                <div className="connection-panel">
                    <h2>Multiplayer Connection</h2>
                    <div className="connection-status">
                        <span className={myPeerId ? 'status-badge status-connected' : 'status-badge status-disconnected'}>
                            {myPeerId ? 'Connected' : 'Connecting...'}
                        </span>
                        {myPeerId && (
                            <span>Your ID: <strong>{myPeerId}</strong></span>
                        )}
                    </div>

                    <div className="connection-controls">
                        <div className="input-group">
                            <label>Connect to Peer ID:</label>
                            <input
                                type="text"
                                value={remotePeerId}
                                onChange={(e) => setRemotePeerId(e.target.value)}
                                placeholder="Enter peer ID"
                            />
                        </div>
                        <button
                            className="btn btn-primary"
                            onClick={connectToPeer}
                            disabled={!myPeerId || !remotePeerId}
                        >
                            Connect
                        </button>
                        <button
                            className="btn btn-success"
                            onClick={() => {
                                setIsHost(true);
                                setShowCharacterCreation(true);
                            }}
                            disabled={!myPeerId}
                        >
                            Host Game
                        </button>
                    </div>

                    {connection && (
                        <div style={{marginTop: '20px'}}>
                            <button
                                className="btn btn-success"
                                onClick={() => setShowCharacterCreation(true)}
                            >
                                Create Character
                            </button>
                        </div>
                    )}
                </div>
            );

            const renderGame = () => {
                const allCombatants = [...characters, ...enemies].filter(c => c.hp > 0);
                const currentCombatant = allCombatants[currentTurn];

                return (
                    <div className="game-container">
                        {/* Left Panel - Party */}
                        <div className="panel">
                            <h3>Party Members</h3>
                            <div className="scroll-container">
                                {characters.map(char => (
                                    <div
                                        key={char.id}
                                        className={`player-card ${currentCombatant?.id === char.id ? 'active' : ''}`}
                                    >
                                        <div style={{fontWeight: 'bold', marginBottom: '5px'}}>
                                            {char.name} {char.isBot && 'ü§ñ'}
                                        </div>
                                        <div style={{fontSize: '0.9em', color: '#a0a0a0'}}>
                                            Lv.{char.level} {char.race} {char.class}
                                        </div>
                                        <div className="health-bar">
                                            <div
                                                className="health-fill"
                                                style={{width: `${(char.hp / char.maxHp) * 100}%`}}
                                            >
                                                {char.hp}/{char.maxHp}
                                            </div>
                                        </div>
                                        <div style={{fontSize: '0.85em', marginTop: '5px'}}>
                                            XP: {char.xp} | Gold: {char.gold}
                                        </div>
                                    </div>
                                ))}
                            </div>

                            {!showCharacterCreation && characters.length === 0 && (
                                <button
                                    className="btn btn-primary"
                                    onClick={() => setShowCharacterCreation(true)}
                                    style={{width: '100%', marginTop: '15px'}}
                                >
                                    Create Character
                                </button>
                            )}
                        </div>

                        {/* Center Panel - Campaign Log */}
                        <div className="panel">
                            <h3>Campaign Log</h3>
                            <div className="campaign-log scroll-container">
                                {combatLog.map((log, idx) => (
                                    <div key={idx} className={`log-entry ${log.type}`}>
                                        {log.message}
                                    </div>
                                ))}
                            </div>

                            {diceResult && (
                                <div className="dice-result">
                                    üé≤ {diceResult}
                                </div>
                            )}

                            {!inCombat && characters.length > 0 && (
                                <div style={{marginTop: '20px'}}>
                                    <h3>Available Quests</h3>
                                    {CAMPAIGN_SCENARIOS.map(scenario => (
                                        <div key={scenario.id} className="quest-card">
                                            <div className="quest-title">{scenario.name}</div>
                                            <div className="quest-description">{scenario.description}</div>
                                            <div className="quest-reward">
                                                Rewards: {scenario.xpReward} XP, {scenario.goldReward} Gold
                                            </div>
                                            <button
                                                className="btn btn-primary"
                                                onClick={() => startScenario(scenario)}
                                                style={{marginTop: '10px'}}
                                            >
                                                Start Quest
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            )}

                            {inCombat && currentCombatant && !currentCombatant.isBot && (
                                <div className="combat-controls">
                                    <button
                                        className="btn btn-danger"
                                        onClick={() => {
                                            const target = enemies.find(e => e.hp > 0);
                                            if (target) {
                                                performAttack(currentCombatant, target);
                                                setTimeout(nextTurn, 1000);
                                            }
                                        }}
                                    >
                                        ‚öîÔ∏è Attack
                                    </button>
                                    <button
                                        className="btn btn-primary"
                                        onClick={() => {
                                            const target = enemies.find(e => e.hp > 0);
                                            if (target) {
                                                performSpecialAbility(currentCombatant, target);
                                                setTimeout(nextTurn, 1000);
                                            }
                                        }}
                                    >
                                        ‚ú® Special
                                    </button>
                                </div>
                            )}
                        </div>

                        {/* Right Panel - Enemies/Info */}
                        <div className="panel">
                            <h3>Combat Status</h3>
                            {inCombat && (
                                <div className="enemy-list scroll-container">
                                    {enemies.map(enemy => (
                                        <div key={enemy.id} className="enemy-card">
                                            <div className="enemy-name">{enemy.name}</div>
                                            <div className="health-bar">
                                                <div
                                                    className="health-fill"
                                                    style={{width: `${(enemy.hp / enemy.maxHp) * 100}%`}}
                                                >
                                                    {enemy.hp}/{enemy.maxHp}
                                                </div>
                                            </div>
                                            <div style={{fontSize: '0.85em', marginTop: '5px'}}>
                                                AC: {enemy.ac} | ATK: +{enemy.attack}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            )}

                            {!inCombat && (
                                <div style={{padding: '20px', textAlign: 'center', color: '#a0a0a0'}}>
                                    No active combat
                                </div>
                            )}

                            <div className="dice-roller">
                                <h3>Dice Roller</h3>
                                <div className="action-buttons">
                                    {[4, 6, 8, 10, 12, 20].map(sides => (
                                        <button
                                            key={sides}
                                            className="btn btn-primary"
                                            onClick={() => rollDice(sides)}
                                            style={{flex: '1 0 30%'}}
                                        >
                                            d{sides}
                                        </button>
                                    ))}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            };

            return (
                <div className="app-container">
                    <div className="header">
                        <h1>‚öîÔ∏è D&D Campaign Manager ‚öîÔ∏è</h1>
                        <p>Embark on epic adventures with friends or AI companions</p>
                    </div>

                    {gameMode === 'menu' && renderMenu()}
                    {gameMode === 'multiplayer' && !connection && !showCharacterCreation && renderMultiplayerSetup()}
                    {(gameMode === 'singleplayer' || connection || characters.length > 0) && renderGame()}
                    {showCharacterCreation && (
                        <CharacterCreationModal
                            onCreateCharacter={createCharacter}
                            onCancel={() => setShowCharacterCreation(false)}
                        />
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
