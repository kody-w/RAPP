<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baldur's Gate Ultimate - Quantum Multiverse Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Cinzel', 'Trajan Pro', Georgia, serif;
            background: #000;
            color: #f0e6d2;
            overflow: hidden;
            user-select: none;
        }

        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght:400;600;700&family=Orbitron:wght@400;700&display=swap');

        /* Main Container */
        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #renderCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #2a1810 0%, #0f0808 100%);
        }

        /* Quantum Timeline Visualizer */
        #quantumTimeline {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 120px;
            background: rgba(10, 5, 30, 0.95);
            border: 2px solid #9933ff;
            border-radius: 15px;
            padding: 10px;
            display: none;
            z-index: 500;
            box-shadow: 0 0 30px rgba(153, 51, 255, 0.6);
        }

        .timeline-branch {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid #9933ff;
            background: radial-gradient(circle, rgba(153, 51, 255, 0.3), rgba(50, 20, 80, 0.8));
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            text-align: center;
        }

        .timeline-branch:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px #9933ff;
        }

        .timeline-branch.active {
            border-color: #ff33ff;
            box-shadow: 0 0 30px #ff33ff;
            animation: quantumPulse 2s infinite;
        }

        @keyframes quantumPulse {
            0%, 100% { box-shadow: 0 0 30px #ff33ff; }
            50% { box-shadow: 0 0 50px #ff33ff, 0 0 70px #9933ff; }
        }

        /* Biometric Panel */
        #biometricPanel {
            position: absolute;
            top: 140px;
            right: 10px;
            width: 250px;
            background: rgba(20, 5, 5, 0.95);
            border: 2px solid #ff0000;
            border-radius: 12px;
            padding: 15px;
            display: none;
            z-index: 400;
        }

        .heart-rate-display {
            font-size: 3em;
            text-align: center;
            color: #ff0000;
            text-shadow: 0 0 20px #ff0000;
            animation: heartbeat 1s infinite;
        }

        @keyframes heartbeat {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .fear-meter {
            height: 30px;
            background: rgba(50, 5, 5, 0.8);
            border-radius: 15px;
            overflow: hidden;
            margin-top: 10px;
            border: 1px solid #ff0000;
        }

        .fear-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600, #ff0000);
            transition: width 0.3s;
            animation: fearPulse 2s infinite;
        }

        @keyframes fearPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        /* WebXR Controls */
        #xrControls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            display: flex;
            gap: 10px;
            z-index: 400;
        }

        .xr-button {
            padding: 15px 25px;
            background: linear-gradient(135deg, #00ff88, #00aa55);
            border: 2px solid #00ffaa;
            border-radius: 10px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .xr-button:hover {
            transform: scale(1.1);
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
        }

        .xr-button.active {
            background: linear-gradient(135deg, #ff0088, #aa0055);
            border-color: #ff00aa;
        }

        /* Neural Interface Panel */
        #neuralPanel {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            background: rgba(5, 20, 40, 0.95);
            border: 2px solid #00ffff;
            border-radius: 12px;
            padding: 15px;
            display: none;
            z-index: 400;
        }

        .neural-stat {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.9em;
        }

        .neural-bar {
            height: 8px;
            background: rgba(0, 50, 80, 0.8);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 3px;
        }

        .neural-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ffff, #0088ff);
            transition: width 0.5s;
            animation: neuralFlow 3s infinite;
        }

        @keyframes neuralFlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.5); }
        }

        /* Blockchain Multiverse Explorer */
        #multiversePanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 700px;
            height: 500px;
            background: rgba(10, 5, 30, 0.98);
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 25px;
            display: none;
            z-index: 1000;
        }

        .world-card {
            display: inline-block;
            width: 150px;
            height: 150px;
            margin: 10px;
            background: linear-gradient(135deg, rgba(50, 30, 80, 0.8), rgba(30, 10, 50, 0.9));
            border: 2px solid #9933ff;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .world-card:hover {
            transform: scale(1.1) rotate(3deg);
            box-shadow: 0 0 30px #9933ff;
        }

        /* Async Multiplayer Notifications */
        #asyncNotifications {
            position: absolute;
            top: 50px;
            right: 10px;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 300;
        }

        .async-notif {
            background: rgba(40, 20, 60, 0.95);
            border-left: 4px solid #ff00ff;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            animation: slideIn 0.5s;
        }

        @keyframes slideIn {
            from { transform: translateX(350px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        /* Audio Visualizer */
        #audioVisualizer {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 100px;
            display: none;
            z-index: 300;
        }

        .audio-bar {
            display: inline-block;
            width: 8px;
            height: 100%;
            background: linear-gradient(to top, #ff0000, #ffff00, #00ff00);
            margin: 0 2px;
            border-radius: 4px 4px 0 0;
            transition: height 0.1s;
        }

        /* Time Loop Indicator */
        #timeLoopIndicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4em;
            color: #00ffff;
            text-shadow: 0 0 50px #00ffff, 0 0 100px #0088ff;
            display: none;
            z-index: 2000;
            animation: timeLoopSpin 2s infinite;
            pointer-events: none;
        }

        @keyframes timeLoopSpin {
            from { transform: translate(-50%, -50%) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg); }
        }

        /* Streaming Chat */
        #streamingChat {
            position: absolute;
            top: 300px;
            right: 10px;
            width: 320px;
            height: 400px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ff69b4;
            border-radius: 12px;
            padding: 15px;
            display: none;
            z-index: 400;
        }

        .chat-message {
            background: rgba(40, 40, 80, 0.6);
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 8px;
            font-size: 0.85em;
        }

        .chat-vote {
            display: inline-block;
            padding: 4px 12px;
            background: #ff69b4;
            border-radius: 12px;
            margin: 2px;
            cursor: pointer;
            font-size: 0.8em;
        }

        /* Main Menu */
        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(60, 40, 30, 0.95), rgba(30, 20, 15, 0.98));
            border: 3px solid #d4af37;
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            z-index: 1000;
            box-shadow: 0 0 100px rgba(212, 175, 55, 0.5);
        }

        #mainMenu h1 {
            color: #f4e4c1;
            font-size: 3em;
            margin-bottom: 15px;
            text-shadow: 0 0 30px rgba(255, 215, 0, 0.8);
            animation: titleGlow 3s ease-in-out infinite;
        }

        #mainMenu h2 {
            color: #00ffff;
            font-size: 1.5em;
            margin-bottom: 10px;
            font-family: 'Orbitron', sans-serif;
        }

        #mainMenu .subtitle {
            color: #9933ff;
            font-size: 1em;
            margin-bottom: 30px;
            font-family: 'Orbitron', sans-serif;
        }

        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 30px rgba(255, 215, 0, 0.8); }
            50% { text-shadow: 0 0 60px rgba(255, 215, 0, 1), 0 0 90px #00ffff; }
        }

        .menuButton {
            display: block;
            width: 320px;
            padding: 18px;
            margin: 15px auto;
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.8), rgba(101, 67, 33, 0.9));
            border: 2px solid #8b6914;
            color: #f4e4c1;
            font-size: 1.2em;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .menuButton:hover {
            background: linear-gradient(135deg, rgba(184, 134, 11, 0.9), rgba(139, 69, 19, 0.95));
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 25px rgba(212, 175, 55, 0.6);
        }

        .feature-tag {
            display: inline-block;
            padding: 3px 8px;
            margin: 2px;
            background: #9933ff;
            border-radius: 10px;
            font-size: 0.7em;
            font-family: 'Orbitron', sans-serif;
        }

        /* HUD */
        #gameHUD {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        #gameHUD > * {
            pointer-events: auto;
        }

        /* AI Dungeon Master */
        #dmPanel {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 700px;
            background: rgba(20, 10, 40, 0.95);
            border: 2px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            display: none;
            z-index: 400;
        }

        #dmText {
            font-size: 1.1em;
            color: #ffd700;
            margin-bottom: 15px;
            line-height: 1.6;
            font-style: italic;
        }

        .dm-choice {
            display: inline-block;
            padding: 10px 20px;
            margin: 5px;
            background: rgba(100, 50, 150, 0.7);
            border: 2px solid #9933ff;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .dm-choice:hover {
            background: rgba(150, 75, 200, 0.9);
            transform: scale(1.05);
            box-shadow: 0 0 20px #9933ff;
        }

        /* Data Controls */
        .data-controls {
            position: fixed;
            top: 10px;
            right: 280px;
            z-index: 2000;
        }

        .data-controls button {
            margin-left: 10px;
            padding: 10px 18px;
            background: rgba(40, 60, 80, 0.9);
            border: 2px solid #00ffff;
            color: #00ffff;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.3s;
        }

        .data-controls button:hover {
            background: rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 20px #00ffff;
        }

        /* Loading Screen */
        #loadingScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
        }

        .loading-text {
            font-size: 2em;
            color: #00ffff;
            text-shadow: 0 0 20px #00ffff;
            animation: loadingPulse 1.5s infinite;
        }

        @keyframes loadingPulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            #mainMenu { width: 90%; padding: 30px; }
            .menuButton { width: 100%; }
            #quantumTimeline { width: 95%; }
            #neuralPanel, #biometricPanel { width: 200px; font-size: 0.85em; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="renderCanvas"></canvas>

        <!-- Loading Screen -->
        <div id="loadingScreen">
            <div class="loading-text">Initializing Quantum Multiverse...</div>
            <div style="margin-top: 20px; color: #9933ff; font-family: 'Orbitron', sans-serif;">
                Loading Neural Networks, WebXR, Blockchain, Biometrics, AI DM, and More...
            </div>
        </div>

        <!-- Main Menu -->
        <div id="mainMenu">
            <h1>BALDUR'S GATE</h1>
            <h2>ULTIMATE EDITION</h2>
            <div class="subtitle">Quantum Multiverse ‚Ä¢ AI-Driven ‚Ä¢ Biometric ‚Ä¢ WebXR</div>
            <div style="margin-bottom: 20px;">
                <span class="feature-tag">QUANTUM TIMELINES</span>
                <span class="feature-tag">AI DUNGEON MASTER</span>
                <span class="feature-tag">BIOMETRIC</span>
                <span class="feature-tag">BLOCKCHAIN WORLDS</span>
                <span class="feature-tag">VR/AR</span>
                <span class="feature-tag">NEURAL AI</span>
                <span class="feature-tag">ASYNC MULTIPLAYER</span>
                <span class="feature-tag">PROCEDURAL AUDIO</span>
                <span class="feature-tag">TIME LOOPS</span>
                <span class="feature-tag">STREAMING</span>
            </div>
            <button class="menuButton" onclick="game.startNewGame()">New Adventure</button>
            <button class="menuButton" onclick="game.continueGame()">Continue Journey</button>
            <button class="menuButton" onclick="game.showMultiverse()">Explore Multiverse</button>
            <button class="menuButton" onclick="game.toggleFeatures()">Toggle Advanced Features</button>
        </div>

        <!-- Game HUD -->
        <div id="gameHUD">
            <!-- Quantum Timeline Visualizer -->
            <div id="quantumTimeline">
                <div style="text-align: center; color: #9933ff; font-size: 0.9em; margin-bottom: 5px;">
                    QUANTUM TIMELINE BRANCHES
                </div>
                <div id="timelineContainer" style="position: relative; height: 80px;"></div>
            </div>

            <!-- Neural Interface Panel -->
            <div id="neuralPanel">
                <h3 style="color: #00ffff; margin-bottom: 10px; font-family: 'Orbitron', sans-serif;">NEURAL INTERFACE</h3>
                <div class="neural-stat">
                    <span>Aggression:</span>
                    <span id="aggressionValue">50%</span>
                </div>
                <div class="neural-bar"><div class="neural-fill" id="aggressionBar" style="width: 50%;"></div></div>

                <div class="neural-stat">
                    <span>Strategy:</span>
                    <span id="strategyValue">50%</span>
                </div>
                <div class="neural-bar"><div class="neural-fill" id="strategyBar" style="width: 50%;"></div></div>

                <div class="neural-stat">
                    <span>Exploration:</span>
                    <span id="explorationValue">50%</span>
                </div>
                <div class="neural-bar"><div class="neural-fill" id="explorationBar" style="width: 50%;"></div></div>

                <div class="neural-stat">
                    <span>Adaptive Difficulty:</span>
                    <span id="difficultyValue">Balanced</span>
                </div>
            </div>

            <!-- Biometric Panel -->
            <div id="biometricPanel">
                <h3 style="color: #ff0000; margin-bottom: 10px; text-align: center;">BIOMETRICS</h3>
                <div class="heart-rate-display" id="heartRate">72</div>
                <div style="text-align: center; font-size: 0.8em; color: #ff6666;">BPM</div>
                <div style="margin-top: 15px; color: #ffaa00;">Fear Level:</div>
                <div class="fear-meter">
                    <div class="fear-fill" id="fearFill" style="width: 30%;"></div>
                </div>
                <div style="margin-top: 10px; font-size: 0.85em;">
                    <div>Combat Penalty: <span id="combatPenalty">-5%</span></div>
                    <div>Damage Taken: <span id="damageMod">+10%</span></div>
                </div>
            </div>

            <!-- WebXR Controls -->
            <div id="xrControls">
                <button class="xr-button" onclick="game.toggleVR()">
                    <span id="vrButtonText">Enter VR</span>
                </button>
                <button class="xr-button" onclick="game.toggleAR()">
                    <span id="arButtonText">Enable AR</span>
                </button>
            </div>

            <!-- AI Dungeon Master Panel -->
            <div id="dmPanel">
                <h3 style="color: #ffd700; margin-bottom: 10px;">AI Dungeon Master</h3>
                <div id="dmText">Welcome, adventurer. Your choices will shape reality itself...</div>
                <div id="dmChoices"></div>
            </div>

            <!-- Async Multiplayer Notifications -->
            <div id="asyncNotifications"></div>

            <!-- Audio Visualizer -->
            <div id="audioVisualizer"></div>

            <!-- Streaming Chat -->
            <div id="streamingChat">
                <h3 style="color: #ff69b4; margin-bottom: 10px;">LIVE VIEWERS</h3>
                <div id="chatMessages" style="height: 300px; overflow-y: auto; margin-bottom: 10px;"></div>
                <div id="activeVote" style="background: rgba(255,105,180,0.2); padding: 10px; border-radius: 8px;"></div>
            </div>

            <!-- Time Loop Indicator -->
            <div id="timeLoopIndicator">‚ü≤</div>
        </div>

        <!-- Multiverse Explorer -->
        <div id="multiversePanel">
            <h2 style="color: #ffd700; text-align: center; margin-bottom: 20px;">BLOCKCHAIN MULTIVERSE</h2>
            <div id="worldsContainer" style="text-align: center; overflow-y: auto; max-height: 400px;"></div>
            <button onclick="game.closeMultiverse()" style="position: absolute; bottom: 20px; right: 20px; padding: 12px 24px; background: #d4af37; border: none; border-radius: 8px; cursor: pointer; font-weight: bold;">Close</button>
        </div>

        <!-- Data Controls -->
        <div class="data-controls">
            <button onclick="game.exportData()">Export Data</button>
            <button onclick="document.getElementById('importFile').click()">Import Data</button>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="game.importData(event)">
        </div>
    </div>

    <script>
        // ULTIMATE BALDUR'S GATE GAME WITH ALL 10 ADVANCED FEATURES
        const APP_NAME = 'baldurs-gate-ultimate';

        class BaldursGateUltimate {
            constructor() {
                this.canvas = document.getElementById('renderCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resizeCanvas();

                // Core game state
                this.gameState = {
                    player: null,
                    inGame: false,
                    paused: false,
                    currentQuest: 0
                };

                // Feature 1: Quantum Timeline System
                this.quantumState = {
                    currentTimeline: 'alpha',
                    timelines: {
                        alpha: { choices: [], divergencePoint: 0, state: {} },
                        beta: { choices: [], divergencePoint: 0, state: {} },
                        gamma: { choices: [], divergencePoint: 0, state: {} }
                    },
                    canMerge: false
                };

                // Feature 2: AI Dungeon Master
                this.aiDM = {
                    context: [],
                    questHistory: [],
                    playerPreferences: { combatWeight: 0.5, explorationWeight: 0.5, dialogueWeight: 0.5 },
                    currentNarrative: ''
                };

                // Feature 3: Biometric System
                this.biometrics = {
                    heartRate: 72,
                    baselineHR: 72,
                    fearLevel: 0,
                    isMonitoring: false,
                    lastUpdate: Date.now()
                };

                // Feature 4: Blockchain Multiverse
                this.multiverse = {
                    worlds: [],
                    currentWorldId: 'local-' + Date.now(),
                    sharedWorlds: [],
                    blockchainHash: this.generateHash()
                };

                // Feature 5: WebXR State
                this.xrState = {
                    vrActive: false,
                    arActive: false,
                    xrSession: null,
                    dodgeTracking: false
                };

                // Feature 6: Neural Interface (Adaptive AI)
                this.neuralInterface = {
                    aggression: 0.5,
                    strategy: 0.5,
                    exploration: 0.5,
                    adaptiveDifficulty: 1.0,
                    learningRate: 0.02,
                    actionHistory: []
                };

                // Feature 7: Async Multiplayer
                this.asyncMultiplayer = {
                    playerId: 'player-' + Math.random().toString(36).substr(2, 9),
                    ghostActions: [],
                    influenceQueue: [],
                    connectedPlayers: []
                };

                // Feature 8: Procedural Audio
                this.audioEngine = {
                    context: null,
                    nodes: {},
                    combatIntensity: 0,
                    currentTheme: 'exploration'
                };

                // Feature 9: Time Loop System
                this.timeLoop = {
                    loopCount: 0,
                    deathMemories: [],
                    persistentKnowledge: [],
                    alternateTimelines: []
                };

                // Feature 10: Streaming Integration
                this.streaming = {
                    viewerCount: 0,
                    activeVote: null,
                    chatMessages: [],
                    viewerInfluence: []
                };

                this.initializeSystems();
                this.loadData();
                this.startGameLoop();
            }

            generateHash() {
                return 'BG' + Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
            }

            initializeSystems() {
                // Initialize Audio Context
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioEngine.context = new AudioContext();
                    this.initializeProceduralAudio();
                } catch (e) {
                    console.log('Audio context not available');
                }

                // Start biometric monitoring simulation
                this.startBiometricMonitoring();

                // Initialize AI DM
                this.generateAIDMQuest();

                // Initialize async multiplayer
                this.initializeAsyncMultiplayer();

                // Initialize streaming simulation
                this.simulateStreamingViewers();

                // Initialize multiverse
                this.generateMultiverseWorlds();

                // Hide loading screen
                setTimeout(() => {
                    document.getElementById('loadingScreen').style.display = 'none';
                }, 2000);
            }

            // FEATURE 1: Quantum Timeline System
            createTimelineBranch(choiceDescription) {
                const timelines = Object.keys(this.quantumState.timelines);
                const availableTimeline = timelines.find(t =>
                    this.quantumState.timelines[t].divergencePoint === 0 && t !== this.quantumState.currentTimeline
                );

                if (availableTimeline) {
                    this.quantumState.timelines[availableTimeline] = {
                        choices: [choiceDescription],
                        divergencePoint: Date.now(),
                        state: JSON.parse(JSON.stringify(this.gameState))
                    };
                    this.updateTimelineUI();
                }
            }

            switchTimeline(timelineId) {
                if (this.quantumState.timelines[timelineId].divergencePoint > 0) {
                    // Save current timeline
                    this.quantumState.timelines[this.quantumState.currentTimeline].state =
                        JSON.parse(JSON.stringify(this.gameState));

                    // Switch to new timeline
                    this.quantumState.currentTimeline = timelineId;
                    this.gameState = JSON.parse(JSON.stringify(
                        this.quantumState.timelines[timelineId].state
                    ));

                    // Show time loop effect
                    this.showTimeLoopEffect();
                    this.updateTimelineUI();
                }
            }

            mergeTimelines() {
                // Merge all timeline benefits
                const merged = {
                    experience: 0,
                    items: [],
                    knowledge: []
                };

                Object.values(this.quantumState.timelines).forEach(timeline => {
                    if (timeline.state && timeline.state.player) {
                        merged.experience += timeline.state.player.experience || 0;
                    }
                });

                // Apply merged benefits
                this.gameState.player.experience += Math.floor(merged.experience * 0.5);
                this.quantumState.canMerge = false;
                alert('Timelines merged! Gained ' + Math.floor(merged.experience * 0.5) + ' bonus experience!');
            }

            updateTimelineUI() {
                const container = document.getElementById('timelineContainer');
                container.innerHTML = '';

                Object.keys(this.quantumState.timelines).forEach((timelineId, index) => {
                    const timeline = this.quantumState.timelines[timelineId];
                    const branch = document.createElement('div');
                    branch.className = 'timeline-branch';
                    if (timelineId === this.quantumState.currentTimeline) {
                        branch.classList.add('active');
                    }
                    branch.style.left = (50 + index * 150) + 'px';
                    branch.textContent = timelineId.toUpperCase();
                    branch.onclick = () => this.switchTimeline(timelineId);

                    if (timeline.divergencePoint === 0) {
                        branch.style.opacity = '0.3';
                    }

                    container.appendChild(branch);
                });
            }

            // FEATURE 2: AI Dungeon Master
            generateAIDMQuest() {
                const questTemplates = [
                    {
                        narrative: "A mysterious portal has appeared in the village square. Strange whispers echo from within...",
                        choices: [
                            { text: "Investigate the portal", type: "exploration" },
                            { text: "Consult the village elder", type: "dialogue" },
                            { text: "Prepare for combat", type: "combat" }
                        ]
                    },
                    {
                        narrative: "You hear screams from the nearby forest. Goblins are attacking a merchant caravan!",
                        choices: [
                            { text: "Charge in to save them", type: "combat" },
                            { text: "Flank from the shadows", type: "strategy" },
                            { text: "Observe and plan", type: "exploration" }
                        ]
                    },
                    {
                        narrative: "An ancient ruin beckons with promises of treasure and danger alike...",
                        choices: [
                            { text: "Enter boldly", type: "exploration" },
                            { text: "Search for hidden entrances", type: "strategy" },
                            { text: "Set up camp and rest first", type: "dialogue" }
                        ]
                    }
                ];

                // Select quest based on player preferences
                const template = questTemplates[Math.floor(Math.random() * questTemplates.length)];
                this.aiDM.currentNarrative = template.narrative;

                document.getElementById('dmText').textContent = template.narrative;
                const choicesContainer = document.getElementById('dmChoices');
                choicesContainer.innerHTML = '';

                template.choices.forEach(choice => {
                    const btn = document.createElement('div');
                    btn.className = 'dm-choice';
                    btn.textContent = choice.text;
                    btn.onclick = () => this.handleDMChoice(choice);
                    choicesContainer.appendChild(btn);
                });
            }

            handleDMChoice(choice) {
                // Record preference for AI learning
                this.aiDM.playerPreferences[choice.type + 'Weight'] =
                    Math.min(1, this.aiDM.playerPreferences[choice.type + 'Weight'] + 0.1);

                // Create timeline branch
                this.createTimelineBranch(choice.text);

                // Update neural interface
                this.neuralInterface.actionHistory.push(choice.type);
                this.updateNeuralInterface();

                // Generate next quest
                setTimeout(() => this.generateAIDMQuest(), 3000);

                // Hide DM panel temporarily
                document.getElementById('dmPanel').style.display = 'none';
                setTimeout(() => {
                    document.getElementById('dmPanel').style.display = 'block';
                }, 3000);
            }

            // FEATURE 3: Biometric Gameplay
            startBiometricMonitoring() {
                // Simulate heart rate (in real implementation, would use Web Bluetooth API)
                setInterval(() => {
                    const inCombat = this.gameState.inCombat || false;
                    const baseVariation = (Math.random() - 0.5) * 10;

                    if (inCombat) {
                        this.biometrics.heartRate = Math.min(180, this.biometrics.baselineHR + 40 + baseVariation);
                    } else {
                        this.biometrics.heartRate = this.biometrics.baselineHR + baseVariation;
                    }

                    // Calculate fear level based on HR increase
                    const hrIncrease = this.biometrics.heartRate - this.biometrics.baselineHR;
                    this.biometrics.fearLevel = Math.max(0, Math.min(100, hrIncrease * 2));

                    this.updateBiometricUI();
                }, 1000);
            }

            updateBiometricUI() {
                document.getElementById('heartRate').textContent = Math.round(this.biometrics.heartRate);
                document.getElementById('fearFill').style.width = this.biometrics.fearLevel + '%';

                const fearPenalty = Math.floor(this.biometrics.fearLevel * 0.5);
                document.getElementById('combatPenalty').textContent = '-' + fearPenalty + '%';
                document.getElementById('damageMod').textContent = '+' + Math.floor(fearPenalty * 0.5) + '%';
            }

            // FEATURE 4: Blockchain Multiverse
            generateMultiverseWorlds() {
                const worldTypes = [
                    { name: "Shadow Realm", difficulty: "Hard", hash: this.generateHash() },
                    { name: "Crystal Dimension", difficulty: "Medium", hash: this.generateHash() },
                    { name: "Chaos Nexus", difficulty: "Extreme", hash: this.generateHash() },
                    { name: "Peaceful Valley", difficulty: "Easy", hash: this.generateHash() },
                    { name: "Time Fractured", difficulty: "Variable", hash: this.generateHash() }
                ];

                this.multiverse.sharedWorlds = worldTypes;
            }

            showMultiverse() {
                const panel = document.getElementById('multiversePanel');
                const container = document.getElementById('worldsContainer');
                container.innerHTML = '';

                this.multiverse.sharedWorlds.forEach(world => {
                    const card = document.createElement('div');
                    card.className = 'world-card';
                    card.innerHTML = `
                        <div style="padding: 15px;">
                            <h4 style="color: #ffd700; margin-bottom: 10px;">${world.name}</h4>
                            <div style="font-size: 0.8em; color: #9933ff;">Difficulty: ${world.difficulty}</div>
                            <div style="font-size: 0.7em; color: #666; margin-top: 8px;">Hash: ${world.hash.substr(0, 10)}...</div>
                        </div>
                    `;
                    card.onclick = () => this.visitWorld(world);
                    container.appendChild(card);
                });

                panel.style.display = 'block';
                document.getElementById('mainMenu').style.display = 'none';
            }

            closeMultiverse() {
                document.getElementById('multiversePanel').style.display = 'none';
                document.getElementById('mainMenu').style.display = 'block';
            }

            visitWorld(world) {
                alert('Traveling to ' + world.name + '... (Blockchain verification: ' + world.hash + ')');
                this.closeMultiverse();
                // In full implementation, would load that world's state
            }

            // FEATURE 5: WebXR Support
            async toggleVR() {
                if (!navigator.xr) {
                    alert('WebXR not supported in this browser');
                    return;
                }

                try {
                    if (!this.xrState.vrActive) {
                        const session = await navigator.xr.requestSession('immersive-vr');
                        this.xrState.xrSession = session;
                        this.xrState.vrActive = true;
                        document.getElementById('vrButtonText').textContent = 'Exit VR';
                        alert('VR Mode Activated! Physical movements now affect gameplay.');
                    } else {
                        if (this.xrState.xrSession) {
                            await this.xrState.xrSession.end();
                        }
                        this.xrState.vrActive = false;
                        document.getElementById('vrButtonText').textContent = 'Enter VR';
                    }
                } catch (e) {
                    alert('VR Mode simulation (WebXR API required for full VR)');
                    this.xrState.vrActive = !this.xrState.vrActive;
                    document.getElementById('vrButtonText').textContent =
                        this.xrState.vrActive ? 'Exit VR' : 'Enter VR';
                }
            }

            async toggleAR() {
                if (!navigator.xr) {
                    alert('WebXR not supported in this browser');
                    return;
                }

                try {
                    if (!this.xrState.arActive) {
                        const session = await navigator.xr.requestSession('immersive-ar');
                        this.xrState.xrSession = session;
                        this.xrState.arActive = true;
                        document.getElementById('arButtonText').textContent = 'Disable AR';
                        alert('AR Mode Activated! Game projected into your room.');
                    } else {
                        if (this.xrState.xrSession) {
                            await this.xrState.xrSession.end();
                        }
                        this.xrState.arActive = false;
                        document.getElementById('arButtonText').textContent = 'Enable AR';
                    }
                } catch (e) {
                    alert('AR Mode simulation (WebXR API required for full AR)');
                    this.xrState.arActive = !this.xrState.arActive;
                    document.getElementById('arButtonText').textContent =
                        this.xrState.arActive ? 'Disable AR' : 'Enable AR';
                }
            }

            // FEATURE 6: Neural Interface (Adaptive AI)
            updateNeuralInterface() {
                // Analyze player behavior
                const recentActions = this.neuralInterface.actionHistory.slice(-10);

                const combatCount = recentActions.filter(a => a === 'combat').length;
                const strategyCount = recentActions.filter(a => a === 'strategy').length;
                const explorationCount = recentActions.filter(a => a === 'exploration').length;

                // Update neural stats
                this.neuralInterface.aggression += (combatCount - 5) * this.neuralInterface.learningRate;
                this.neuralInterface.strategy += (strategyCount - 3) * this.neuralInterface.learningRate;
                this.neuralInterface.exploration += (explorationCount - 2) * this.neuralInterface.learningRate;

                // Clamp values
                this.neuralInterface.aggression = Math.max(0, Math.min(1, this.neuralInterface.aggression));
                this.neuralInterface.strategy = Math.max(0, Math.min(1, this.neuralInterface.strategy));
                this.neuralInterface.exploration = Math.max(0, Math.min(1, this.neuralInterface.exploration));

                // Adjust difficulty
                const avgSkill = (this.neuralInterface.aggression + this.neuralInterface.strategy + this.neuralInterface.exploration) / 3;
                this.neuralInterface.adaptiveDifficulty = 0.5 + avgSkill;

                this.updateNeuralUI();
            }

            updateNeuralUI() {
                const agg = Math.round(this.neuralInterface.aggression * 100);
                const str = Math.round(this.neuralInterface.strategy * 100);
                const exp = Math.round(this.neuralInterface.exploration * 100);

                document.getElementById('aggressionValue').textContent = agg + '%';
                document.getElementById('aggressionBar').style.width = agg + '%';

                document.getElementById('strategyValue').textContent = str + '%';
                document.getElementById('strategyBar').style.width = str + '%';

                document.getElementById('explorationValue').textContent = exp + '%';
                document.getElementById('explorationBar').style.width = exp + '%';

                const difficultyLabels = ['Beginner', 'Easy', 'Balanced', 'Hard', 'Expert'];
                const difficultyIndex = Math.floor(this.neuralInterface.adaptiveDifficulty * 4);
                document.getElementById('difficultyValue').textContent = difficultyLabels[difficultyIndex];
            }

            // FEATURE 7: Async Multiplayer
            initializeAsyncMultiplayer() {
                // Simulate other players' ghost actions
                setInterval(() => {
                    const actions = [
                        "Player_Shadow defeated a dragon in the eastern ruins",
                        "Player_Phantom discovered a hidden treasure",
                        "Player_Echo completed a legendary quest",
                        "Player_Wraith unlocked a secret area"
                    ];

                    const action = actions[Math.floor(Math.random() * actions.length)];
                    this.addAsyncNotification(action);

                    // Random world influence
                    if (Math.random() > 0.7) {
                        this.asyncMultiplayer.influenceQueue.push({
                            type: 'environment',
                            effect: 'weather_change',
                            strength: Math.random()
                        });
                    }
                }, 15000);
            }

            addAsyncNotification(message) {
                const container = document.getElementById('asyncNotifications');
                const notif = document.createElement('div');
                notif.className = 'async-notif';
                notif.textContent = message;
                container.insertBefore(notif, container.firstChild);

                // Remove old notifications
                while (container.children.length > 5) {
                    container.removeChild(container.lastChild);
                }

                // Auto-remove after 10 seconds
                setTimeout(() => {
                    if (notif.parentNode) {
                        notif.remove();
                    }
                }, 10000);
            }

            // FEATURE 8: Procedural Audio Generation
            initializeProceduralAudio() {
                if (!this.audioEngine.context) return;

                // Create oscillators and filters for dynamic music
                this.audioEngine.nodes.bass = this.audioEngine.context.createOscillator();
                this.audioEngine.nodes.melody = this.audioEngine.context.createOscillator();
                this.audioEngine.nodes.atmosphere = this.audioEngine.context.createOscillator();

                this.audioEngine.nodes.bassGain = this.audioEngine.context.createGain();
                this.audioEngine.nodes.melodyGain = this.audioEngine.context.createGain();
                this.audioEngine.nodes.atmosphereGain = this.audioEngine.context.createGain();

                // Initial setup (muted by default for user experience)
                this.audioEngine.nodes.bassGain.gain.value = 0;
                this.audioEngine.nodes.melodyGain.gain.value = 0;
                this.audioEngine.nodes.atmosphereGain.gain.value = 0;
            }

            updateProceduralAudio(intensity) {
                if (!this.audioEngine.context) return;

                this.audioEngine.combatIntensity = intensity;

                // Adjust frequencies based on combat intensity
                // (In real implementation, would be much more sophisticated)
                const baseFreq = 60 + (intensity * 40);
                const melodyFreq = 220 + (intensity * 180);

                // Visual representation only (actual audio muted for UX)
                this.updateAudioVisualizer(intensity);
            }

            updateAudioVisualizer(intensity) {
                const container = document.getElementById('audioVisualizer');
                container.innerHTML = '';

                for (let i = 0; i < 60; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'audio-bar';
                    const height = Math.random() * intensity * 80 + 20;
                    bar.style.height = height + 'px';
                    container.appendChild(bar);
                }
            }

            // FEATURE 9: Time Loop Mechanics
            triggerTimeLop() {
                this.timeLoop.loopCount++;

                // Show time loop effect
                this.showTimeLoopEffect();

                // Save death memory
                this.timeLoop.deathMemories.push({
                    location: 'current_location',
                    cause: 'combat',
                    timestamp: Date.now()
                });

                // Create alternate timeline instead of reset
                const newTimelineId = 'loop_' + this.timeLoop.loopCount;
                this.quantumState.timelines[newTimelineId] = {
                    choices: ['Death Timeline ' + this.timeLoop.loopCount],
                    divergencePoint: Date.now(),
                    state: JSON.parse(JSON.stringify(this.gameState))
                };

                alert('Time loop detected! Timeline branched. Loop count: ' + this.timeLoop.loopCount);
            }

            showTimeLoopEffect() {
                const indicator = document.getElementById('timeLoopIndicator');
                indicator.style.display = 'block';
                setTimeout(() => {
                    indicator.style.display = 'none';
                }, 2000);
            }

            // FEATURE 10: Streaming Integration
            simulateStreamingViewers() {
                setInterval(() => {
                    this.streaming.viewerCount = Math.floor(100 + Math.random() * 500);

                    // Simulate chat messages
                    const messages = [
                        "Use the fire spell!",
                        "Go left, there's treasure!",
                        "Watch out for the trap!",
                        "Epic gameplay!",
                        "Try the stealth approach"
                    ];

                    if (Math.random() > 0.7) {
                        const msg = messages[Math.floor(Math.random() * messages.length)];
                        this.addChatMessage('Viewer' + Math.floor(Math.random() * 1000), msg);
                    }

                    // Random viewer votes
                    if (Math.random() > 0.8 && !this.streaming.activeVote) {
                        this.startViewerVote();
                    }
                }, 5000);
            }

            addChatMessage(username, message) {
                const container = document.getElementById('chatMessages');
                const msg = document.createElement('div');
                msg.className = 'chat-message';
                msg.innerHTML = `<strong style="color: #ff69b4;">${username}:</strong> ${message}`;
                container.appendChild(msg);
                container.scrollTop = container.scrollHeight;

                // Keep only last 20 messages
                while (container.children.length > 20) {
                    container.removeChild(container.firstChild);
                }
            }

            startViewerVote() {
                const votes = [
                    { option: "Attack", icon: "‚öîÔ∏è" },
                    { option: "Defend", icon: "üõ°Ô∏è" },
                    { option: "Magic", icon: "‚ú®" }
                ];

                this.streaming.activeVote = { options: votes, results: {} };

                const voteContainer = document.getElementById('activeVote');
                voteContainer.innerHTML = '<div style="margin-bottom: 8px;">Viewers are voting...</div>';

                votes.forEach(vote => {
                    const btn = document.createElement('div');
                    btn.className = 'chat-vote';
                    btn.textContent = vote.icon + ' ' + vote.option;
                    btn.onclick = () => this.castViewerVote(vote.option);
                    voteContainer.appendChild(btn);
                });

                // Auto-resolve vote
                setTimeout(() => {
                    this.resolveViewerVote();
                }, 10000);
            }

            castViewerVote(option) {
                if (!this.streaming.activeVote.results[option]) {
                    this.streaming.activeVote.results[option] = 0;
                }
                this.streaming.activeVote.results[option]++;
            }

            resolveViewerVote() {
                if (!this.streaming.activeVote) return;

                const results = this.streaming.activeVote.results;
                const winner = Object.keys(results).reduce((a, b) =>
                    (results[a] || 0) > (results[b] || 0) ? a : b, '');

                alert('Viewers chose: ' + winner + '! Applying effect...');

                document.getElementById('activeVote').innerHTML =
                    '<div style="color: #44ff44;">Vote complete: ' + winner + '</div>';

                this.streaming.activeVote = null;
            }

            // Core Game Functions
            startNewGame() {
                this.gameState = {
                    player: {
                        name: 'Hero',
                        level: 1,
                        hp: 100,
                        maxHp: 100,
                        experience: 0
                    },
                    inGame: true,
                    currentQuest: 1
                };

                document.getElementById('mainMenu').style.display = 'none';
                document.getElementById('gameHUD').style.display = 'block';
                document.getElementById('quantumTimeline').style.display = 'block';
                document.getElementById('neuralPanel').style.display = 'block';
                document.getElementById('biometricPanel').style.display = 'block';
                document.getElementById('dmPanel').style.display = 'block';
                document.getElementById('asyncNotifications').style.display = 'block';
                document.getElementById('audioVisualizer').style.display = 'block';
                document.getElementById('streamingChat').style.display = 'block';

                this.updateTimelineUI();
                this.updateNeuralUI();
                this.generateAIDMQuest();

                this.addChatMessage('System', 'New adventure started! Good luck!');
            }

            continueGame() {
                if (this.gameState.inGame) {
                    this.startNewGame();
                } else {
                    alert('No saved game found. Starting new adventure!');
                    this.startNewGame();
                }
            }

            toggleFeatures() {
                alert('All 10 advanced features are active!\n\n' +
                    '1. Quantum Timelines - Top center\n' +
                    '2. AI Dungeon Master - Bottom center\n' +
                    '3. Biometric Monitor - Top right\n' +
                    '4. Blockchain Multiverse - Main menu\n' +
                    '5. WebXR VR/AR - Bottom left\n' +
                    '6. Neural Interface - Top left\n' +
                    '7. Async Multiplayer - Right notifications\n' +
                    '8. Procedural Audio - Bottom visualizer\n' +
                    '9. Time Loops - Triggered on death\n' +
                    '10. Streaming Chat - Bottom right');
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            startGameLoop() {
                const loop = () => {
                    this.update();
                    this.render();
                    requestAnimationFrame(loop);
                };
                loop();
            }

            update() {
                if (!this.gameState.inGame) return;

                // Update audio based on game state
                const intensity = this.gameState.inCombat ? 0.8 : 0.2;
                this.updateProceduralAudio(intensity);

                // Process async multiplayer influences
                if (this.asyncMultiplayer.influenceQueue.length > 0) {
                    const influence = this.asyncMultiplayer.influenceQueue.shift();
                    // Apply influence to game world
                }
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Render game world (simplified for this demo)
                this.ctx.fillStyle = '#ffd700';
                this.ctx.font = '24px Cinzel';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Baldur\'s Gate Ultimate - All Systems Active',
                    this.canvas.width / 2, this.canvas.height / 2);

                // Render XR effects if active
                if (this.xrState.vrActive) {
                    this.ctx.fillStyle = '#00ff88';
                    this.ctx.font = '18px Orbitron';
                    this.ctx.fillText('VR MODE ACTIVE', this.canvas.width / 2, this.canvas.height / 2 + 40);
                }

                if (this.xrState.arActive) {
                    this.ctx.fillStyle = '#ff0088';
                    this.ctx.font = '18px Orbitron';
                    this.ctx.fillText('AR MODE ACTIVE', this.canvas.width / 2, this.canvas.height / 2 + 70);
                }
            }

            // Data persistence
            saveData() {
                const saveData = {
                    gameState: this.gameState,
                    quantumState: this.quantumState,
                    aiDM: this.aiDM,
                    biometrics: this.biometrics,
                    multiverse: this.multiverse,
                    neuralInterface: this.neuralInterface,
                    asyncMultiplayer: this.asyncMultiplayer,
                    timeLoop: this.timeLoop,
                    streaming: this.streaming
                };
                localStorage.setItem(APP_NAME, JSON.stringify(saveData));
            }

            loadData() {
                const savedData = localStorage.getItem(APP_NAME);
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        this.gameState = data.gameState || this.gameState;
                        this.quantumState = data.quantumState || this.quantumState;
                        this.aiDM = data.aiDM || this.aiDM;
                        this.neuralInterface = data.neuralInterface || this.neuralInterface;
                        this.timeLoop = data.timeLoop || this.timeLoop;
                    } catch (e) {
                        console.error('Failed to load data:', e);
                    }
                }
            }

            exportData() {
                this.saveData();
                const data = localStorage.getItem(APP_NAME);
                const blob = new Blob([data], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `baldurs-gate-ultimate-${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                URL.revokeObjectURL(url);
            }

            importData(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        localStorage.setItem(APP_NAME, e.target.result);
                        location.reload();
                    } catch (error) {
                        alert('Invalid save file');
                    }
                };
                reader.readAsText(file);
            }
        }

        // Initialize game
        let game;
        window.addEventListener('load', () => {
            game = new BaldursGateUltimate();
        });

        window.addEventListener('resize', () => {
            if (game) game.resizeCanvas();
        });

        // Auto-save every 30 seconds
        setInterval(() => {
            if (game && game.gameState.inGame) {
                game.saveData();
            }
        }, 30000);
    </script>
</body>
</html>