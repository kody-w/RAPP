<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Baldur's Gate Chronicles - 3D Enhanced Edition ‚öîÔ∏è</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Lora:ital,wght@0,400;0,600;1,400&display=swap');

        :root {
            --gold: #f4d03f;
            --dark-gold: #c5a747;
            --crimson: #c41e3a;
            --dark-bg: #1a0f0a;
            --panel-bg: rgba(30, 20, 15, 0.95);
            --success: #4ade80;
            --fail: #ef4444;
        }

        body {
            font-family: 'Lora', Georgia, serif;
            background: radial-gradient(ellipse at center, #1a0f0a 0%, #0a0505 100%);
            color: #f0e6d2;
            overflow: hidden;
            user-select: none;
        }

        #tutorialOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.92);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .tutorialContent {
            background: linear-gradient(135deg, rgba(60, 40, 30, 0.98) 0%, rgba(30, 20, 15, 0.98) 100%);
            border: 3px solid var(--gold);
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.9), 0 0 100px rgba(244, 208, 63, 0.4);
        }

        .tutorialContent h2 {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(244, 208, 63, 0.8);
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% { text-shadow: 0 0 20px rgba(244, 208, 63, 0.8); }
            50% { text-shadow: 0 0 40px rgba(255, 215, 0, 1); }
        }

        .tutorialContent p {
            font-size: 1.2em;
            line-height: 1.8;
            margin-bottom: 30px;
            color: #e8dcc4;
        }

        .tutorialButton {
            padding: 15px 40px;
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.9) 0%, rgba(101, 67, 33, 0.95) 100%);
            border: 2px solid var(--dark-gold);
            color: #f4e4c1;
            font-family: 'Cinzel', serif;
            font-size: 1.1em;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.4s;
            margin: 0 10px;
        }

        .tutorialButton:hover {
            transform: translateY(-3px);
            border-color: var(--gold);
            box-shadow: 0 8px 25px rgba(244, 208, 63, 0.5);
        }

        .tutorialButton:focus {
            outline: 3px solid var(--gold);
            outline-offset: 2px;
        }

        .xpBar {
            margin: 15px 0;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            height: 24px;
            border: 2px solid var(--dark-gold);
            overflow: hidden;
            position: relative;
        }

        .xpFill {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 1s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.6);
        }

        .xpText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.9em;
            font-weight: 700;
            color: #fff;
            text-shadow: 2px 2px 4px #000;
            font-family: 'Cinzel', serif;
        }

        #gameContainer {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        #visualSection {
            flex: 1;
            position: relative;
            border-right: 3px solid rgba(244, 208, 63, 0.3);
            background: #000;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #modeToggle {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 12px 24px;
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.9) 0%, rgba(101, 67, 33, 0.95) 100%);
            border: 2px solid var(--gold);
            color: #f4e4c1;
            font-family: 'Cinzel', serif;
            font-size: 1em;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0,0,0,0.7);
            transition: all 0.3s;
            z-index: 100;
        }

        #modeToggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(244, 208, 63, 0.5);
        }

        #textSection {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, var(--panel-bg) 0%, rgba(20, 15, 10, 0.98) 100%);
            backdrop-filter: blur(10px);
        }

        #narrativeBox {
            flex: 1;
            padding: 40px;
            overflow-y: auto;
            font-size: 1.1em;
            line-height: 1.8;
            color: #e8dcc4;
        }

        #narrativeBox::-webkit-scrollbar {
            width: 12px;
        }

        #narrativeBox::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
        }

        #narrativeBox::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #8b5a3c, #654321);
            border-radius: 6px;
        }

        .narrativeText {
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            animation: textReveal 0.8s ease-out;
        }

        @keyframes textReveal {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .narrativeTitle {
            font-family: 'Cinzel', serif;
            font-size: 1.8em;
            color: var(--gold);
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(244, 208, 63, 0.6);
            animation: titleGlow 3s ease-in-out infinite;
        }

        .combatText {
            background: rgba(196, 30, 58, 0.15);
            padding: 15px;
            border-left: 4px solid var(--crimson);
            margin: 15px 0;
            border-radius: 4px;
            animation: slideIn 0.5s;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .diceRoll {
            display: inline-block;
            background: linear-gradient(135deg, #4a2511, #8b4513);
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 600;
            color: #ffd700;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            animation: diceShake 0.5s;
        }

        @keyframes diceShake {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        .successText {
            color: var(--success);
            font-weight: 600;
            animation: successPulse 0.5s;
        }

        @keyframes successPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .failText {
            color: var(--fail);
            font-weight: 600;
            animation: failShake 0.5s;
        }

        @keyframes failShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .initiativeTracker {
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid var(--gold);
            border-radius: 8px;
            padding: 10px;
            margin: 15px 0;
        }

        .initiativeEntry {
            display: flex;
            align-items: center;
            padding: 5px;
            margin: 3px 0;
            background: rgba(197, 167, 71, 0.15);
            border-radius: 4px;
            gap: 10px;
        }

        .initiativeEntry.active {
            background: rgba(244, 208, 63, 0.3);
            border: 1px solid var(--gold);
        }

        .statusEffect {
            display: inline-block;
            padding: 2px 8px;
            margin: 0 3px;
            background: rgba(70, 130, 180, 0.3);
            border-radius: 3px;
            font-size: 0.85em;
            color: #87ceeb;
        }

        #choiceBox {
            padding: 30px;
            border-top: 2px solid rgba(244, 208, 63, 0.3);
            background: linear-gradient(135deg, rgba(40, 25, 15, 0.95) 0%, rgba(20, 15, 10, 0.98) 100%);
        }

        .choice {
            display: block;
            width: 100%;
            padding: 18px 25px;
            margin: 12px 0;
            background: linear-gradient(135deg, rgba(60, 40, 25, 0.9) 0%, rgba(40, 25, 15, 0.95) 100%);
            border: 2px solid rgba(197, 167, 71, 0.6);
            border-radius: 10px;
            color: #f4e4c1;
            font-family: 'Lora', serif;
            font-size: 1.05em;
            text-align: left;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
        }

        .choice::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
            transition: left 0.5s;
        }

        .choice:hover::before {
            left: 100%;
        }

        .choice:hover {
            background: linear-gradient(135deg, rgba(100, 65, 40, 0.95) 0%, rgba(60, 40, 25, 0.98) 100%);
            border-color: var(--gold);
            transform: translateX(5px);
            box-shadow: 0 6px 20px rgba(244, 208, 63, 0.4);
        }

        .choice:focus {
            outline: 3px solid var(--gold);
            outline-offset: 2px;
        }

        .choiceLabel {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: var(--gold);
        }

        .choiceDescription {
            font-size: 0.95em;
            color: #c0b090;
        }

        .choiceSkill {
            display: inline-block;
            margin-top: 8px;
            padding: 4px 10px;
            background: rgba(70, 130, 180, 0.3);
            border-radius: 4px;
            font-size: 0.9em;
            color: #87ceeb;
        }

        #charPanel {
            position: absolute;
            top: 80px;
            left: 20px;
            background: linear-gradient(135deg, rgba(30, 20, 10, 0.95) 0%, rgba(20, 15, 5, 0.98) 100%);
            border: 2px solid rgba(244, 208, 63, 0.4);
            border-radius: 12px;
            padding: 15px;
            min-width: 260px;
            max-height: 70vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0,0,0,0.8);
            backdrop-filter: blur(8px);
            z-index: 50;
        }

        #charPanel::-webkit-scrollbar {
            width: 8px;
        }

        #charPanel::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #8b5a3c, #654321);
            border-radius: 4px;
        }

        .charCard {
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(0,0,0,0.4);
            border-radius: 8px;
            border: 1px solid rgba(197, 167, 71, 0.5);
            transition: all 0.3s;
        }

        .charCard:hover {
            border-color: var(--gold);
            box-shadow: 0 0 15px rgba(244, 208, 63, 0.3);
        }

        .charName {
            font-family: 'Cinzel', serif;
            color: var(--gold);
            font-size: 1.1em;
            margin-bottom: 5px;
        }

        .charClass {
            font-size: 0.9em;
            color: #c0c0c0;
            margin-bottom: 8px;
        }

        .healthBar {
            height: 18px;
            background: rgba(20, 5, 5, 0.9);
            border-radius: 9px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(196, 30, 58, 0.5);
            margin-bottom: 5px;
        }

        .healthFill {
            height: 100%;
            background: linear-gradient(90deg, #c41e3a, #ef4444);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
        }

        .healthText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 0.8em;
            font-weight: 600;
            color: #fff;
            text-shadow: 1px 1px 2px #000;
        }

        .charStats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 8px;
            font-size: 0.85em;
        }

        .statBox {
            background: rgba(0,0,0,0.3);
            padding: 5px;
            border-radius: 4px;
            text-align: center;
        }

        .statLabel {
            color: var(--dark-gold);
            font-weight: 600;
        }

        .statValue {
            color: #f4e4c1;
            font-weight: 700;
        }

        #mainMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(60, 40, 30, 0.98) 0%, rgba(30, 20, 15, 0.98) 100%);
            border: 3px solid var(--gold);
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.9), 0 0 100px rgba(244, 208, 63, 0.3);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        #mainMenu h1 {
            font-family: 'Cinzel', serif;
            color: #f4e4c1;
            font-size: 3em;
            margin-bottom: 15px;
            text-shadow: 0 0 20px rgba(244, 208, 63, 0.8);
            animation: titleGlow 3s ease-in-out infinite;
        }

        #mainMenu h2 {
            color: #c0c0c0;
            font-size: 1.2em;
            margin-bottom: 30px;
        }

        .menuButton {
            display: block;
            width: 300px;
            padding: 18px;
            margin: 15px auto;
            background: linear-gradient(135deg, rgba(139, 69, 19, 0.9) 0%, rgba(101, 67, 33, 0.95) 100%);
            border: 2px solid var(--dark-gold);
            color: #f4e4c1;
            font-family: 'Cinzel', serif;
            font-size: 1.2em;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.4s;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .menuButton:hover {
            background: linear-gradient(135deg, rgba(184, 134, 11, 0.95) 0%, rgba(139, 69, 19, 0.98) 100%);
            transform: translateY(-3px);
            border-color: var(--gold);
            box-shadow: 0 8px 25px rgba(244, 208, 63, 0.5);
        }

        .menuButton:focus {
            outline: 3px solid var(--gold);
            outline-offset: 2px;
        }

        .dataControls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }

        .dataControls button {
            margin-right: 10px;
            padding: 10px 20px;
            background: rgba(40, 25, 15, 0.9);
            border: 2px solid rgba(244, 208, 63, 0.5);
            color: #f4e4c1;
            font-family: 'Cinzel', serif;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .dataControls button:hover {
            border-color: var(--gold);
            box-shadow: 0 0 15px rgba(244, 208, 63, 0.4);
        }

        .dataControls button:focus {
            outline: 3px solid var(--gold);
            outline-offset: 2px;
        }

        .levelUpNotif {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.3), rgba(34, 197, 94, 0.3));
            border: 2px solid #4ade80;
            padding: 20px;
            border-radius: 12px;
            margin: 20px 0;
            text-align: center;
            animation: levelUpGlow 2s ease-in-out infinite;
        }

        @keyframes levelUpGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(74, 222, 128, 0.4); }
            50% { box-shadow: 0 0 40px rgba(74, 222, 128, 0.8); }
        }

        @media (max-width: 1024px) {
            #gameContainer {
                flex-direction: column;
            }

            #visualSection {
                height: 40vh;
                border-right: none;
                border-bottom: 3px solid rgba(244, 208, 63, 0.3);
            }

            #textSection {
                height: 60vh;
            }

            #charPanel {
                top: 10px;
                left: 10px;
                min-width: 180px;
                padding: 10px;
                max-height: 35vh;
            }

            #narrativeBox {
                padding: 20px;
                font-size: 1em;
            }

            #choiceBox {
                padding: 20px;
            }

            .menuButton {
                width: 250px;
                font-size: 1em;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        .hide {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="tutorialOverlay" style="display: none;">
        <div class="tutorialContent">
            <h2>‚öîÔ∏è Welcome, Adventurer! ‚öîÔ∏è</h2>
            <p>You are about to embark on a perilous journey through the cursed lands of Ravenloft. Your choices matter, your dice rolls determine fate, and glory awaits the brave.</p>
            <p><strong>Controls:</strong><br>
            ‚Ä¢ Click choices to make decisions<br>
            ‚Ä¢ Use keyboard (1-4) for quick selections<br>
            ‚Ä¢ Toggle between 2D and 3D views<br>
            ‚Ä¢ Press ESC to close dialogs<br>
            ‚Ä¢ Export/Import to save your progress</p>
            <button class="tutorialButton" onclick="game.startTutorial()" tabindex="0">Start Tutorial</button>
            <button class="tutorialButton" onclick="game.skipTutorial()" tabindex="0">Skip to Adventure</button>
        </div>
    </div>

    <div class="dataControls">
        <button onclick="exportData()" aria-label="Export game save" tabindex="0">üíæ Export Save</button>
        <button onclick="document.getElementById('importFile').click()" aria-label="Import game save" tabindex="0">üìÅ Import Save</button>
        <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importData(event)">
    </div>

    <div id="gameContainer">
        <div id="visualSection">
            <canvas id="renderCanvas"></canvas>
            <button id="modeToggle" onclick="game.toggleViewMode()" aria-label="Toggle between 2D and 3D view" tabindex="0">Switch to 3D</button>
            <div id="charPanel" role="region" aria-label="Party information"></div>
        </div>

        <div id="textSection">
            <div id="narrativeBox" role="main" aria-live="polite" aria-atomic="true"></div>
            <div id="choiceBox" role="navigation" aria-label="Available choices"></div>
        </div>
    </div>

    <div id="mainMenu">
        <h1>‚öîÔ∏è Baldur's Gate Chronicles ‚öîÔ∏è</h1>
        <h2>3D Enhanced Edition v4.0</h2>
        <button class="menuButton" onclick="game.newGame()" tabindex="0">üó°Ô∏è New Adventure</button>
        <button class="menuButton" onclick="game.continueGame()" tabindex="0">üìú Continue</button>
        <button class="menuButton" onclick="game.showSettings()" tabindex="0">‚öôÔ∏è Settings</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const APP_NAME = 'baldurs-gate-chronicles-3d-v4';

        const DOMCache = {};
        function getElement(id) {
            if (!DOMCache[id]) {
                DOMCache[id] = document.getElementById(id);
            }
            return DOMCache[id];
        }

        let gameState = {
            currentScene: 'intro',
            characters: [],
            choices: {},
            inventory: [],
            viewMode: '2d',
            tutorial: false,
            xp: 0,
            level: 1,
            xpToNextLevel: 300,
            relationships: {
                elara: 0,
                thorin: 0,
                lyra: 0
            },
            combat: {
                active: false,
                round: 0,
                initiative: [],
                currentTurn: 0,
                statusEffects: new Map()
            },
            settings: {
                difficulty: 'normal',
                reducedMotion: false
            }
        };

        const ITEMS = {
            health_potion: {
                name: 'Health Potion',
                description: 'Restores 2d4+2 HP',
                rarity: 'common',
                icon: 'üß™',
                effect: { type: 'heal', amount: '2d4+2' }
            },
            greater_health_potion: {
                name: 'Greater Health Potion',
                description: 'Restores 4d4+4 HP',
                rarity: 'uncommon',
                icon: '‚ú®',
                effect: { type: 'heal', amount: '4d4+4' }
            },
            magic_sword: {
                name: 'Longsword +1',
                description: '+1 to attack and damage rolls',
                rarity: 'uncommon',
                icon: '‚öîÔ∏è',
                effect: { type: 'weapon', bonus: 1 }
            }
        };

        const SCENES = {
            intro: {
                title: "üåÑ The Road to Thornhaven",
                text: `The late afternoon sun casts long shadows across the dirt road. You and your companions have been traveling for three days, and the small village of Thornhaven should be just over the next hill.

<strong>Your companions are:</strong>
‚Ä¢ <strong style="color: #f4d03f">Elara</strong>, a wise cleric of the light
‚Ä¢ <strong style="color: #8b4513">Thorin</strong>, a stalwart dwarf fighter
‚Ä¢ <strong style="color: #9370db">Lyra</strong>, a nimble half-elf rogue

As you crest the hill, you see smoke rising from the village ahead.

<em>"We need to move, now!"</em> Elara shouts.`,
                sceneData: {
                    environment: 'road_forest',
                    partyPositions: [
                        {id: 'player', x: 0, y: 0, z: 0},
                        {id: 'elara', x: -2, y: 0, z: -1},
                        {id: 'thorin', x: 2, y: 0, z: -1},
                        {id: 'lyra', x: 0, y: 0, z: -2}
                    ]
                },
                choices: [
                    {
                        id: 'rush_village',
                        label: "‚öîÔ∏è Rush to the village!",
                        description: "Charge ahead to help the villagers.",
                        nextScene: 'goblin_attack'
                    },
                    {
                        id: 'scout_first',
                        label: "üëÅÔ∏è Send Lyra to scout ahead",
                        description: "Better to know what you're dealing with first.",
                        skill: 'Stealth',
                        dc: 12,
                        success: 'scout_success',
                        failure: 'scout_failure'
                    }
                ]
            },
            goblin_attack: {
                title: "‚öîÔ∏è Goblins in the Square!",
                text: `You burst into the village square to find chaos. Three goblins are terrorizing villagers!

<div class="combatText">
<strong>‚öîÔ∏è COMBAT INITIATED!</strong><br>
Rolling initiative for all combatants...
</div>`,
                sceneData: {
                    environment: 'village_square',
                    combat: true,
                    partyPositions: [
                        {id: 'player', x: -3, y: 0, z: 0},
                        {id: 'elara', x: -4, y: 0, z: -1},
                        {id: 'thorin', x: -2, y: 0, z: -1},
                        {id: 'lyra', x: -3, y: 0, z: -2}
                    ],
                    enemies: [
                        {id: 'goblin1', type: 'Goblin Warrior', x: 3, y: 0, z: 0, hp: 7, maxHp: 7, ac: 13},
                        {id: 'goblin2', type: 'Goblin Archer', x: 4, y: 0, z: -1, hp: 5, maxHp: 5, ac: 12},
                        {id: 'goblin3', type: 'Goblin Pyro', x: 3, y: 0, z: 1, hp: 5, maxHp: 5, ac: 11}
                    ]
                },
                choices: [
                    {
                        id: 'aggressive_attack',
                        label: "‚ö° Aggressive stance!",
                        description: "Attack with full force!",
                        nextScene: 'combat_victory'
                    },
                    {
                        id: 'defensive_stance',
                        label: "üõ°Ô∏è Defensive formation!",
                        description: "Take defensive positions.",
                        nextScene: 'combat_victory'
                    }
                ]
            },
            scout_success: {
                title: "üéØ Successful Reconnaissance",
                text: `Lyra returns with intel about the goblin positions.

<div class="combatText">
<strong>‚úÖ Scout Successful!</strong><br>
‚Ä¢ You gain advantage on your first attack<br>
‚Ä¢ Party gains +2 initiative
</div>`,
                sceneData: {
                    environment: 'road_forest',
                    partyPositions: [
                        {id: 'player', x: 0, y: 0, z: 0},
                        {id: 'elara', x: -2, y: 0, z: -1},
                        {id: 'thorin', x: 2, y: 0, z: -1},
                        {id: 'lyra', x: 0, y: 0, z: -2}
                    ]
                },
                choices: [
                    {
                        id: 'attack_prepared',
                        label: "‚öîÔ∏è Attack!",
                        description: "Move in with tactical advantage.",
                        nextScene: 'goblin_attack'
                    }
                ]
            },
            scout_failure: {
                title: "‚ö†Ô∏è Alert!",
                text: `A twig snaps! The goblins are alerted!

<div class="combatText">
<strong>‚ùå Scout Failed!</strong><br>
‚Ä¢ Goblins gain +2 initiative<br>
‚Ä¢ You lose the element of surprise
</div>`,
                sceneData: {
                    environment: 'road_forest',
                    partyPositions: [
                        {id: 'player', x: 0, y: 0, z: 0},
                        {id: 'elara', x: -2, y: 0, z: -1},
                        {id: 'thorin', x: 2, y: 0, z: -1},
                        {id: 'lyra', x: 0, y: 0, z: -2}
                    ]
                },
                choices: [
                    {
                        id: 'charge',
                        label: "‚öîÔ∏è Charge!",
                        description: "No turning back now!",
                        nextScene: 'goblin_attack'
                    }
                ]
            },
            combat_victory: {
                title: "üéâ Victory!",
                text: `The goblin threat has been neutralized!

<div style="text-align: center; font-size: 2em; margin: 20px 0;">
<span class="successText">‚öîÔ∏è VICTORY! ‚öîÔ∏è</span>
</div>

<div class="combatText">
<strong>üèÜ Rewards:</strong><br>
‚Ä¢ Experience Gained: <span class="successText">+150 XP</span><br>
‚Ä¢ Gold Found: 15 pieces<br>
‚Ä¢ Loot: 3√ó Health Potions
</div>

An elderly man approaches. <em>"Thank you, brave travelers. I am Elder Aldric."</em>`,
                sceneData: {
                    environment: 'village_square',
                    partyPositions: [
                        {id: 'player', x: 0, y: 0, z: 0},
                        {id: 'elara', x: -2, y: 0, z: -1},
                        {id: 'thorin', x: 2, y: 0, z: -1},
                        {id: 'lyra', x: 0, y: 0, z: -2}
                    ],
                    npcs: [{id: 'elder', x: 4, y: 0, z: 0, name: 'Elder Aldric'}]
                },
                choices: [
                    {
                        id: 'return',
                        label: "üè† Return to Main Menu",
                        description: "End of demo. Export your save!",
                        nextScene: 'intro'
                    }
                ]
            }
        };

        const CHARACTER_TEMPLATES = {
            player: {
                name: 'Hero',
                class: 'Fighter',
                level: 1,
                maxHp: 12,
                currentHp: 12,
                ac: 16,
                initiative: 2,
                str: 16,
                dex: 14,
                con: 14,
                int: 10,
                wis: 12,
                cha: 10
            },
            elara: {
                name: 'Elara',
                class: 'Cleric',
                level: 1,
                maxHp: 10,
                currentHp: 10,
                ac: 14,
                initiative: 1,
                str: 10,
                dex: 12,
                con: 14,
                int: 13,
                wis: 16,
                cha: 14
            },
            thorin: {
                name: 'Thorin',
                class: 'Fighter',
                level: 1,
                maxHp: 14,
                currentHp: 14,
                ac: 18,
                initiative: 0,
                str: 17,
                dex: 10,
                con: 16,
                int: 8,
                wis: 11,
                cha: 9
            },
            lyra: {
                name: 'Lyra',
                class: 'Rogue',
                level: 1,
                maxHp: 8,
                currentHp: 8,
                ac: 15,
                initiative: 4,
                str: 8,
                dex: 18,
                con: 12,
                int: 14,
                wis: 13,
                cha: 12
            }
        };

        const DIFFICULTY_MODIFIERS = {
            easy: {
                enemyHpMultiplier: 0.75,
                enemyAcBonus: -2,
                enemyDamageMultiplier: 0.8,
                xpMultiplier: 0.8
            },
            normal: {
                enemyHpMultiplier: 1.0,
                enemyAcBonus: 0,
                enemyDamageMultiplier: 1.0,
                xpMultiplier: 1.0
            },
            hard: {
                enemyHpMultiplier: 1.5,
                enemyAcBonus: 2,
                enemyDamageMultiplier: 1.3,
                xpMultiplier: 1.5
            }
        };

        function rollDice(notation) {
            const match = notation.match(/(\d+)d(\d+)(?:([+-])(\d+))?/);
            if (!match) return parseInt(notation) || 0;

            const [, numDice, diceSize, operator, modifier] = match;
            let total = 0;
            let rolls = [];

            for (let i = 0; i < parseInt(numDice); i++) {
                const roll = Math.floor(Math.random() * parseInt(diceSize)) + 1;
                rolls.push(roll);
                total += roll;
            }

            if (operator && modifier) {
                total += operator === '+' ? parseInt(modifier) : -parseInt(modifier);
            }

            return {total, rolls, notation};
        }

        function rollD20(advantage = false, disadvantage = false) {
            const roll1 = Math.floor(Math.random() * 20) + 1;
            if (!advantage && !disadvantage) return roll1;

            const roll2 = Math.floor(Math.random() * 20) + 1;
            return advantage ? Math.max(roll1, roll2) : Math.min(roll1, roll2);
        }

        function awardXP(amount) {
            const modifier = DIFFICULTY_MODIFIERS[gameState.settings.difficulty];
            const adjustedXP = Math.floor(amount * modifier.xpMultiplier);

            gameState.xp += adjustedXP;

            while (gameState.xp >= gameState.xpToNextLevel) {
                levelUp();
            }

            return adjustedXP;
        }

        function levelUp() {
            gameState.level++;
            gameState.xp -= gameState.xpToNextLevel;
            gameState.xpToNextLevel = Math.floor(gameState.xpToNextLevel * 1.5);

            const narrativeBox = getElement('narrativeBox');
            narrativeBox.innerHTML += `
                <div class="levelUpNotif">
                    <strong>üéâ LEVEL UP! üéâ</strong><br>
                    You are now Level ${gameState.level}!<br>
                    <em>Your adventures grow more legendary...</em>
                </div>
            `;

            gameState.characters.forEach(char => {
                char.level = gameState.level;
                char.maxHp += Math.floor(Math.random() * 6) + 3;
                char.currentHp = char.maxHp;
            });
        }

        // THREE.JS 3D RENDERER
        class Renderer3D {
            constructor(canvas) {
                this.canvas = canvas;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(
                    50,
                    canvas.width / canvas.height,
                    0.1,
                    1000
                );

                // Isometric camera position
                this.camera.position.set(10, 10, 10);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(canvas.width, canvas.height);
                this.renderer.setClearColor(0x0a0505, 1);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffd700, 0.8);
                directionalLight.position.set(5, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                const pointLight = new THREE.PointLight(0xf4d03f, 0.6, 20);
                pointLight.position.set(0, 5, 0);
                this.scene.add(pointLight);

                // Store 3D objects
                this.objects = new Map();
                this.animationFrameId = null;
            }

            render(sceneData) {
                // Clear previous objects
                this.objects.forEach(obj => this.scene.remove(obj));
                this.objects.clear();

                // Create ground
                const groundGeometry = new THREE.PlaneGeometry(20, 20);
                const groundMaterial = new THREE.MeshStandardMaterial({
                    color: this.getEnvironmentColor(sceneData.environment),
                    roughness: 0.8,
                    metalness: 0.2
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                this.objects.set('ground', ground);

                // Add grid
                const gridHelper = new THREE.GridHelper(20, 20, 0xf4d03f, 0x8b6914);
                gridHelper.material.opacity = 0.3;
                gridHelper.material.transparent = true;
                this.scene.add(gridHelper);
                this.objects.set('grid', gridHelper);

                // Create characters
                if (sceneData.partyPositions) {
                    sceneData.partyPositions.forEach(char => {
                        const mesh = this.createCharacter(char);
                        this.scene.add(mesh);
                        this.objects.set(char.id, mesh);
                    });
                }

                // Create enemies
                if (sceneData.enemies) {
                    sceneData.enemies.forEach(enemy => {
                        const mesh = this.createEnemy(enemy);
                        this.scene.add(mesh);
                        this.objects.set(enemy.id, mesh);
                    });
                }

                // Create NPCs
                if (sceneData.npcs) {
                    sceneData.npcs.forEach(npc => {
                        const mesh = this.createNPC(npc);
                        this.scene.add(mesh);
                        this.objects.set(npc.id, mesh);
                    });
                }

                // Start animation loop
                this.animate();
            }

            getEnvironmentColor(env) {
                const colors = {
                    'road_forest': 0x5a7d4e,
                    'village_square': 0x8b7355,
                    'dark_forest': 0x2d3e25,
                    'ruins': 0x3a3a3a
                };
                return colors[env] || colors['road_forest'];
            }

            createCharacter(char) {
                const group = new THREE.Group();

                // Body (cylinder)
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 16);
                const colors = {
                    player: 0x4682b4,
                    elara: 0xf4d03f,
                    thorin: 0x8b4513,
                    lyra: 0x9370db
                };
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: colors[char.id] || 0x4682b4,
                    roughness: 0.5,
                    metalness: 0.3
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.75;
                body.castShadow = true;
                group.add(body);

                // Head (sphere)
                const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffd0a0,
                    roughness: 0.7
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 2;
                head.castShadow = true;
                group.add(head);

                // Weapon indicator (cone)
                const weaponGeometry = new THREE.ConeGeometry(0.1, 0.8, 8);
                const weaponMaterial = new THREE.MeshStandardMaterial({
                    color: 0xc0c0c0,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                weapon.position.set(0.4, 1, 0);
                weapon.rotation.z = -Math.PI / 4;
                weapon.castShadow = true;
                group.add(weapon);

                // Position the group
                group.position.set(char.x, char.y, char.z);

                return group;
            }

            createEnemy(enemy) {
                const group = new THREE.Group();

                // Body (pyramid for menacing look)
                const bodyGeometry = new THREE.ConeGeometry(0.4, 1.2, 4);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0xc41e3a,
                    roughness: 0.6,
                    metalness: 0.4
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.6;
                body.castShadow = true;
                group.add(body);

                // Head (smaller sphere)
                const headGeometry = new THREE.SphereGeometry(0.25, 12, 12);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8b0000,
                    roughness: 0.8
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.4;
                head.castShadow = true;
                group.add(head);

                // Eyes (glowing)
                const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff00,
                    emissive: 0xffff00
                });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.1, 1.5, 0.2);
                group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.1, 1.5, 0.2);
                group.add(rightEye);

                group.position.set(enemy.x, enemy.y, enemy.z);

                return group;
            }

            createNPC(npc) {
                const group = new THREE.Group();

                // Simple robed figure
                const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.6, 16);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8b7355,
                    roughness: 0.9
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.8;
                body.castShadow = true;
                group.add(body);

                const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const headMaterial = new THREE.MeshStandardMaterial({
                    color: 0xf0d0a0,
                    roughness: 0.7
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.9;
                head.castShadow = true;
                group.add(head);

                group.position.set(npc.x, npc.y, npc.z);

                return group;
            }

            animate() {
                this.animationFrameId = requestAnimationFrame(() => this.animate());

                // Gentle camera rotation
                const time = Date.now() * 0.0001;
                this.camera.position.x = Math.cos(time) * 12;
                this.camera.position.z = Math.sin(time) * 12;
                this.camera.lookAt(0, 0, 0);

                // Animate objects (gentle bobbing)
                this.objects.forEach((obj, id) => {
                    if (id !== 'ground' && id !== 'grid') {
                        obj.rotation.y += 0.005;
                        obj.position.y = Math.sin(Date.now() * 0.001 + obj.position.x) * 0.1;
                    }
                });

                this.renderer.render(this.scene, this.camera);
            }

            stopAnimation() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            resize(width, height) {
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            dispose() {
                this.stopAnimation();
                this.objects.forEach(obj => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) obj.material.dispose();
                });
                this.renderer.dispose();
            }
        }

        // 2D CANVAS RENDERER
        class Renderer2D {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
            }

            render(sceneData) {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawBackground(sceneData.environment);

                if (sceneData.partyPositions) {
                    sceneData.partyPositions.forEach(char => this.drawCharacter(char));
                }

                if (sceneData.enemies) {
                    sceneData.enemies.forEach(enemy => this.drawEnemy(enemy));
                }

                if (sceneData.npcs) {
                    sceneData.npcs.forEach(npc => this.drawNPC(npc));
                }
            }

            drawBackground(env) {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                const backgrounds = {
                    'road_forest': ['#5a7d4e', '#2d3e25'],
                    'village_square': ['#8b7355', '#4a3820'],
                    'dark_forest': ['#2d3e25', '#1a1f15'],
                    'ruins': ['#3a3a3a', '#1a1a1a']
                };

                const colors = backgrounds[env] || backgrounds['road_forest'];
                const grad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, w/2);
                grad.addColorStop(0, colors[0]);
                grad.addColorStop(1, colors[1]);
                ctx.fillStyle = grad;
                ctx.fillRect(0, 0, w, h);

                ctx.strokeStyle = 'rgba(244, 208, 63, 0.08)';
                ctx.lineWidth = 1;
                const gridSize = 40;
                for (let x = 0; x < w; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }
                for (let y = 0; y < h; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }

            drawCharacter(char) {
                const ctx = this.ctx;
                const x = this.canvas.width / 2 + char.x * 50;
                const y = this.canvas.height / 2 + char.z * 50;

                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(x, y + 35, 20, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                const grad = ctx.createRadialGradient(x, y, 5, x, y, 25);
                const colors = {
                    player: ['#4682b4', '#1e3a5f'],
                    elara: ['#f4d03f', '#c5a747'],
                    thorin: ['#8b4513', '#5a2d0c'],
                    lyra: ['#9370db', '#5a3a7a']
                };

                const color = colors[char.id] || ['#666', '#333'];
                grad.addColorStop(0, color[0]);
                grad.addColorStop(1, color[1]);

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.arc(x, y, 25, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = 'rgba(244, 208, 63, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                const charData = gameState.characters.find(c => c === CHARACTER_TEMPLATES[char.id]);
                if (charData) {
                    ctx.fillStyle = '#f4e4c1';
                    ctx.font = 'bold 14px Cinzel';
                    ctx.textAlign = 'center';
                    ctx.fillText(charData.name, x, y - 35);
                }
            }

            drawEnemy(enemy) {
                const ctx = this.ctx;
                const x = this.canvas.width / 2 + enemy.x * 50;
                const y = this.canvas.height / 2 + enemy.z * 50;

                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(x, y + 25, 15, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                const grad = ctx.createRadialGradient(x, y, 5, x, y, 20);
                grad.addColorStop(0, '#c41e3a');
                grad.addColorStop(1, '#7a1225');

                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.moveTo(x, y - 20);
                ctx.lineTo(x - 18, y + 15);
                ctx.lineTo(x + 18, y + 15);
                ctx.closePath();
                ctx.fill();

                ctx.strokeStyle = 'rgba(239, 68, 68, 0.9)';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(x - 6, y - 5, 3, 0, Math.PI * 2);
                ctx.arc(x + 6, y - 5, 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = '#ef4444';
                ctx.font = 'bold 12px Cinzel';
                ctx.textAlign = 'center';
                ctx.fillText(enemy.type, x, y - 30);
            }

            drawNPC(npc) {
                const ctx = this.ctx;
                const x = this.canvas.width / 2 + npc.x * 50;
                const y = this.canvas.height / 2 + npc.z * 50;

                ctx.fillStyle = '#c0c0c0';
                ctx.beginPath();
                ctx.arc(x, y, 20, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#f4d03f';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        class GameEngine {
            constructor() {
                this.canvas = getElement('renderCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.renderer2D = new Renderer2D(this.canvas, this.ctx);
                this.renderer3D = null;

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.loadGameState();
                this.initKeyboardShortcuts();
            }

            resizeCanvas() {
                const visualSection = getElement('visualSection');
                this.canvas.width = visualSection.clientWidth;
                this.canvas.height = visualSection.clientHeight;

                if (this.renderer3D) {
                    this.renderer3D.resize(this.canvas.width, this.canvas.height);
                }

                this.render();
            }

            loadGameState() {
                const saved = localStorage.getItem(APP_NAME);
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        Object.assign(gameState, data);
                    } catch (e) {
                        console.error('Failed to load save:', e);
                    }
                }
            }

            saveGameState() {
                localStorage.setItem(APP_NAME, JSON.stringify(gameState));
            }

            initKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.key >= '1' && e.key <= '4') {
                        const choices = document.querySelectorAll('.choice');
                        const index = parseInt(e.key) - 1;
                        if (choices[index]) {
                            choices[index].click();
                        }
                    }
                    if (e.key === 'Escape') {
                        const tutorial = getElement('tutorialOverlay');
                        if (tutorial && tutorial.style.display !== 'none') {
                            this.skipTutorial();
                        }
                    }
                });
            }

            newGame() {
                getElement('mainMenu').style.display = 'none';
                getElement('tutorialOverlay').style.display = 'flex';
            }

            startTutorial() {
                gameState.tutorial = true;
                this.initializeGame();
                getElement('tutorialOverlay').style.display = 'none';
            }

            skipTutorial() {
                gameState.tutorial = false;
                this.initializeGame();
                getElement('tutorialOverlay').style.display = 'none';
            }

            initializeGame() {
                gameState = {
                    currentScene: 'intro',
                    characters: [
                        {...CHARACTER_TEMPLATES.player},
                        {...CHARACTER_TEMPLATES.elara},
                        {...CHARACTER_TEMPLATES.thorin},
                        {...CHARACTER_TEMPLATES.lyra}
                    ],
                    choices: {},
                    inventory: ['health_potion', 'health_potion', 'health_potion'],
                    viewMode: '2d',
                    tutorial: gameState.tutorial,
                    xp: 0,
                    level: 1,
                    xpToNextLevel: 300,
                    relationships: {
                        elara: 0,
                        thorin: 0,
                        lyra: 0
                    },
                    combat: {
                        active: false,
                        round: 0,
                        initiative: [],
                        currentTurn: 0,
                        statusEffects: new Map()
                    },
                    settings: gameState.settings
                };

                this.showScene(gameState.currentScene);
                this.updateCharacterPanel();
                this.saveGameState();
            }

            continueGame() {
                if (gameState.currentScene && gameState.characters.length > 0) {
                    getElement('mainMenu').style.display = 'none';
                    this.showScene(gameState.currentScene);
                    this.updateCharacterPanel();
                } else {
                    alert('No saved game found! Starting new adventure...');
                    this.newGame();
                }
            }

            showSettings() {
                const currentDifficulty = gameState.settings.difficulty;
                const newDifficulty = prompt(
                    `‚öôÔ∏è SETTINGS\n\nCurrent Difficulty: ${currentDifficulty}\n\nChoose difficulty:\n‚Ä¢ easy\n‚Ä¢ normal\n‚Ä¢ hard`,
                    currentDifficulty
                );

                if (newDifficulty && ['easy', 'normal', 'hard'].includes(newDifficulty.toLowerCase())) {
                    gameState.settings.difficulty = newDifficulty.toLowerCase();
                    this.saveGameState();
                    alert(`Difficulty set to: ${gameState.settings.difficulty}`);
                }
            }

            showScene(sceneId) {
                const scene = SCENES[sceneId];
                if (!scene) {
                    console.error('Scene not found:', sceneId);
                    return;
                }

                gameState.currentScene = sceneId;

                const narrativeBox = getElement('narrativeBox');
                narrativeBox.innerHTML = `
                    <div class="narrativeTitle">${scene.title}</div>
                    <div class="narrativeText">${scene.text}</div>
                `;

                const choiceBox = getElement('choiceBox');
                choiceBox.innerHTML = '';

                scene.choices.forEach((choice, index) => {
                    const btn = document.createElement('button');
                    btn.className = 'choice';
                    btn.setAttribute('tabindex', '0');
                    btn.setAttribute('role', 'button');
                    btn.innerHTML = `
                        <span class="choiceLabel">[${index + 1}] ${choice.label}</span>
                        <span class="choiceDescription">${choice.description}</span>
                        ${choice.skill ? `<span class="choiceSkill">${choice.skill} DC ${choice.dc}</span>` : ''}
                    `;
                    btn.onclick = () => this.handleChoice(choice);
                    choiceBox.appendChild(btn);
                });

                this.render();
                this.updateXPBar();
                narrativeBox.scrollTop = 0;
                this.saveGameState();
            }

            handleChoice(choice) {
                gameState.choices[gameState.currentScene] = choice.id;

                if (choice.skill) {
                    const roll = rollD20();
                    const modifier = 3;
                    const total = roll + modifier;

                    const result = total >= choice.dc ? 'success' : 'failure';
                    const nextScene = choice[result];

                    const narrativeBox = getElement('narrativeBox');
                    narrativeBox.innerHTML += `
                        <div class="narrativeText" style="margin-top: 20px;">
                            <strong>üé≤ ${choice.skill} Check:</strong><br>
                            <span class="diceRoll">d20(${roll}) + ${modifier} = ${total}</span> vs DC ${choice.dc}
                            ${result === 'success' ?
                                '<br><span class="successText">‚úì SUCCESS!</span>' :
                                '<br><span class="failText">‚úó FAILURE!</span>'}
                        </div>
                    `;

                    if (result === 'success') {
                        const xpGained = awardXP(25);
                        narrativeBox.innerHTML += `
                            <div class="narrativeText">
                                <span class="successText">+${xpGained} XP</span>
                            </div>
                        `;
                    }

                    setTimeout(() => this.showScene(nextScene), 1500);
                } else if (choice.nextScene) {
                    if (choice.nextScene === 'combat_victory') {
                        const xpGained = awardXP(150);
                        const narrativeBox = getElement('narrativeBox');
                        narrativeBox.innerHTML += `
                            <div class="narrativeText">
                                <span class="successText">+${xpGained} XP gained!</span>
                            </div>
                        `;
                    }

                    this.showScene(choice.nextScene);
                }
            }

            toggleViewMode() {
                gameState.viewMode = gameState.viewMode === '2d' ? '3d' : '2d';
                getElement('modeToggle').textContent =
                    gameState.viewMode === '2d' ? 'Switch to 3D' : 'Switch to 2D';

                if (gameState.viewMode === '3d') {
                    if (!this.renderer3D) {
                        this.renderer3D = new Renderer3D(this.canvas);
                    }
                } else {
                    if (this.renderer3D) {
                        this.renderer3D.stopAnimation();
                    }
                }

                this.render();
                this.saveGameState();
            }

            render() {
                const scene = SCENES[gameState.currentScene];
                if (!scene || !scene.sceneData) return;

                if (gameState.viewMode === '2d') {
                    if (this.renderer3D) {
                        this.renderer3D.stopAnimation();
                    }
                    this.renderer2D.render(scene.sceneData);
                } else if (gameState.viewMode === '3d') {
                    if (!this.renderer3D) {
                        this.renderer3D = new Renderer3D(this.canvas);
                    }
                    this.renderer3D.render(scene.sceneData);
                }
            }

            updateXPBar() {
                const panel = getElement('charPanel');
                const existingXPBar = panel.querySelector('.xpBar');
                if (existingXPBar) {
                    existingXPBar.remove();
                }

                const xpPercent = (gameState.xp / gameState.xpToNextLevel) * 100;
                const xpBar = document.createElement('div');
                xpBar.className = 'xpBar';
                xpBar.innerHTML = `
                    <div class="xpFill" style="width: ${xpPercent}%"></div>
                    <div class="xpText">Level ${gameState.level} - ${gameState.xp}/${gameState.xpToNextLevel} XP</div>
                `;

                const firstChild = panel.firstElementChild;
                if (firstChild && firstChild.nextSibling) {
                    panel.insertBefore(xpBar, firstChild.nextSibling);
                } else {
                    panel.appendChild(xpBar);
                }
            }

            updateCharacterPanel() {
                const panel = getElement('charPanel');
                panel.innerHTML = '<div style="font-family: Cinzel; color: var(--gold); margin-bottom: 15px; font-size: 1.1em;">‚öîÔ∏è Party</div>';

                gameState.characters.forEach(char => {
                    const hpPercent = (char.currentHp / char.maxHp) * 100;
                    const card = document.createElement('div');
                    card.className = 'charCard';
                    card.setAttribute('role', 'article');
                    card.setAttribute('aria-label', `${char.name} character card`);
                    card.innerHTML = `
                        <div class="charName">${char.name}</div>
                        <div class="charClass">Level ${char.level} ${char.class}</div>
                        <div class="healthBar" role="progressbar" aria-valuenow="${char.currentHp}" aria-valuemin="0" aria-valuemax="${char.maxHp}">
                            <div class="healthFill" style="width: ${hpPercent}%"></div>
                            <div class="healthText">${char.currentHp}/${char.maxHp} HP</div>
                        </div>
                        <div class="charStats">
                            <div class="statBox">
                                <div class="statLabel">STR</div>
                                <div class="statValue">${char.str || 10}</div>
                            </div>
                            <div class="statBox">
                                <div class="statLabel">DEX</div>
                                <div class="statValue">${char.dex || 10}</div>
                            </div>
                            <div class="statBox">
                                <div class="statLabel">CON</div>
                                <div class="statValue">${char.con || 10}</div>
                            </div>
                        </div>
                    `;
                    panel.appendChild(card);
                });

                this.updateXPBar();
            }
        }

        function exportData() {
            const dataStr = JSON.stringify(gameState, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `baldurs-gate-save-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    Object.assign(gameState, data);
                    game.showScene(gameState.currentScene);
                    game.updateCharacterPanel();
                    game.saveGameState();
                    alert('‚úì Save loaded successfully!');
                } catch (error) {
                    alert('‚úó Invalid save file!');
                }
            };
            reader.readAsText(file);
        }

        let game;
        window.addEventListener('DOMContentLoaded', () => {
            game = new GameEngine();
        });
    </script>
</body>
</html>
